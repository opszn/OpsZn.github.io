<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>詹楠博客</title>
  
  <subtitle>世间无限丹青手，一片伤心画不成。谁谓伤心画不成？画人心逐世人情。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.opszn.com/"/>
  <updated>2019-08-16T09:27:10.185Z</updated>
  <id>https://www.opszn.com/</id>
  
  <author>
    <name>Zhan Nan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>docker容器3</title>
    <link href="https://www.opszn.com/2019/03/25/docker%E5%AE%B9%E5%99%A83/"/>
    <id>https://www.opszn.com/2019/03/25/docker容器3/</id>
    <published>2019-03-25T07:53:07.000Z</published>
    <updated>2019-08-16T09:27:10.185Z</updated>
    
    <content type="html"><![CDATA[<h1 id="docker容器3"><a href="#docker容器3" class="headerlink" title="docker容器3"></a>docker容器3</h1><h2 id="docker三剑客介绍"><a href="#docker三剑客介绍" class="headerlink" title="docker三剑客介绍"></a>docker三剑客介绍</h2><p>为了把容器化技术的优点发挥得更好，docker公司先后推出了三大技术:</p><ul><li>docker-machine</li><li>docker-compose</li><li>docker-swarm</li></ul><p>使用”三剑客”可以帮助我们解决docker host维护,多容器编排部署,多个docker host集群的各个难题。</p><h3 id="docker-machine"><a href="#docker-machine" class="headerlink" title="docker-machine"></a>docker-machine</h3><p>通过之前的文章我们对于docker使用Linux内核技术（namespace，cgroup等），但是如果我们需要在Windows上或者mac上运行docker怎么去做呢？</p><p>所以就需要用到docker-machine</p><p><img src="/2019/03/25/docker容器3/docker_machine.png" alt></p><p>docker-machine就是docker公司官方提出的,用于在各种平台上快速创建具有docker服务的虚拟机的技术.</p><p>参考: <a href="https://docs.docker.com/machine/install-machine/#install-machine-directly" target="_blank" rel="noopener">https://docs.docker.com/machine/install-machine/#install-machine-directly</a></p><p><img src="/2019/03/25/docker容器3/docker-machine-1.png" alt></p><p>但是目前docker最主要的还是在Linux上运行，所以这个docker-machine的话涉及的还是比较少，只做了解即可。</p><h3 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>用容器运行一个服务,需要使用<code>docker run</code>命令。但如果我要运行多个服务呢?</p><p>假设我要运行一个web服务,还要运行一个db服务,那么是用一个容器运行,还是用多个容器运行呢?</p><p>一个容器运行多个服务会造成镜像的复杂度提高,<strong>docker倾向于一个容器运行一个应用</strong>。</p><p>那么复杂的架构就会需要很多的容器,并且需要它们之间有关联(容器之间的依赖和连接)就更复杂了。</p><p>这个复杂的问题需要解决,这就涉及到了<strong>容器编排</strong>的问题了。</p><p>docker-compose就是可以做容器编排的小工具，它可以在一个文件中定义多个容器,只用一行命令就可以让一切就绪并运行。</p><h4 id="使用docker-compose的三个步骤"><a href="#使用docker-compose的三个步骤" class="headerlink" title="使用docker-compose的三个步骤"></a>使用docker-compose的三个步骤</h4><p>docker-compose将所管理的容器分为了三层</p><table><thead><tr><th>project（工程）</th><th>一个工程内包含多个服务，每个服务中定义了容器运行的镜像，参数等</th></tr></thead><tbody><tr><td>service（服务）</td><td>一个服务中可包括多个容器实例</td></tr><tr><td>containerr（容器）</td><td>一般一个容器运行一个应用</td></tr></tbody></table><p>使用Compose基本上分为三步：</p><ol><li>Dockerfile 定义应用的运行环境（构建镜像)</li><li>docker-compose.yml 定义组成应用的各服务</li><li>docker-compose up 构建并启动整个应用</li></ol><h4 id="常见的语法"><a href="#常见的语法" class="headerlink" title="常见的语法"></a>常见的语法</h4><p>docker compose使用<code>.yml</code>或<code>.yaml</code>后缀来</p><p>参考: <a href="https://docs.docker.com/compose/compose-file/" target="_blank" rel="noopener">https://docs.docker.com/compose/compose-file/</a></p><h5 id="build"><a href="#build" class="headerlink" title="build"></a><strong>build</strong></h5><p>指定镜像构建时的dockerfile目录,格式一般为绝对路径目录或相对路径目录(dockerfile需要命名为Dockerfile)</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">build: /path/to/build/dir</span><br><span class="line">或者</span><br><span class="line">build: ./dir</span><br></pre></td></tr></table></figure><h5 id="image"><a href="#image" class="headerlink" title="image"></a><strong>image</strong></h5><p>指定要启动容器的镜像</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">image: redis</span><br><span class="line">image: ubuntu:<span class="number">14.04</span></span><br><span class="line">image: tutum/influxdb</span><br><span class="line">image: example-registry.com:<span class="number">4000</span>/postgresql</span><br><span class="line">image: a4bc65fd</span><br></pre></td></tr></table></figure><p>如果镜像不存在,compose尝试拉它.</p><p>如果指定了构建, 可以使用指定的选项构建它,并使用指定的tag进行标记。</p><h5 id="environment"><a href="#environment" class="headerlink" title="environment"></a><strong>environment</strong></h5><p>设置镜像变量，它可以保存变量到镜像里面，也就是说启动的容器也会包含这些变量设置</p><p><code>environment</code> 和 Dockerfile 中的 <code>ENV</code> 指令一样会把变量一直保存在镜像,容器中</p><p><strong>格式</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">environment:</span><br><span class="line">  RACK_ENV: development</span><br><span class="line">  SHOW: <span class="string">'true'</span></span><br><span class="line">或</span><br><span class="line">environment:</span><br><span class="line">  - RACK_ENV=development</span><br><span class="line">  - SHOW=true</span><br></pre></td></tr></table></figure><h5 id="expose"><a href="#expose" class="headerlink" title="expose"></a><strong>expose</strong></h5><p>这个标签与Dockerfile中的 <code>EXPOSE</code> 指令一样，用于指定暴露的端口，但只将端口暴露给连接的服务，而不暴露给主机.</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expose:</span><br><span class="line"> - <span class="string">"3000"</span></span><br><span class="line"> - <span class="string">"8000"</span></span><br></pre></td></tr></table></figure><h5 id="ports"><a href="#ports" class="headerlink" title="ports"></a><strong>ports</strong></h5><p>映射端口，可以使用 <code>HOST:CONTAINER</code> 的方式指定端口，也可以指定容器端口（选择临时主机端口），宿主机会随机映射端口</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ports:</span><br><span class="line"> - <span class="string">"3000"</span></span><br><span class="line"> - <span class="string">"3000-3005"</span></span><br><span class="line"> - <span class="string">"8000:8000"</span></span><br><span class="line"> - <span class="string">"9090-9091:8080-8081"</span></span><br><span class="line"> - <span class="string">"49100:22"</span></span><br><span class="line"> - <span class="string">"127.0.0.1:8001:8001"</span></span><br><span class="line"> - <span class="string">"127.0.0.1:5000-5010:5000-5010"</span></span><br><span class="line"> - <span class="string">"6060:6060/udp"</span></span><br></pre></td></tr></table></figure><h5 id="restart"><a href="#restart" class="headerlink" title="restart"></a><strong>restart</strong></h5><p>指定Docker容器的重启策略</p><p>默认值为 <code>no</code> ，即在任何情况下都不会重新启动容器</p><p>当值为 <code>always</code> 时，容器退出时总是重新启动；</p><p>当值为 <code>on-failure</code>时，当出现 <code>on-failure</code> 报错（非正常退出，退出状态非0）,才会重启容器</p><p>当值为<code>unless-stopped</code>时, 在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">restart: <span class="string">"no"</span></span><br><span class="line">restart: always</span><br><span class="line">restart: on-failure</span><br><span class="line">restart: on-failure:<span class="number">3</span></span><br><span class="line">restart: unless-stopped</span><br></pre></td></tr></table></figure><h5 id="volume"><a href="#volume" class="headerlink" title="volume"></a><strong>volume</strong></h5><p>数据卷挂载，可以直接使用 <code>HOST:CONTAINER</code> 这样的格式</p><p>或者使用 <code>HOST:CONTAINER:ro</code> 这样的格式，ro代表数据卷是只读的</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">volumes:</span><br><span class="line">  <span class="comment"># 只是指定一个路径，Docker 会自动在创建一个数据卷（这个路径是容器内部的）。</span></span><br><span class="line">  - /var/lib/mysql</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 使用绝对路径挂载数据卷</span></span><br><span class="line">  - /opt/<span class="keyword">data</span>:/var/lib/mysql</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 以Compose配置文件为中心的相对路径作为数据卷挂载到容器。</span></span><br><span class="line">  - ./cache:/tmp/cache</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 使用用户的相对路径（~/ 表示的目录是 /home/&lt;用户目录&gt;/ 或者 /root/）。</span></span><br><span class="line">  - ~/configs:/etc/configs/:ro</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 已经存在的命名的数据卷。</span></span><br><span class="line">  - datavolume:/var/lib/mysql</span><br></pre></td></tr></table></figure><h5 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a><strong>depends_on</strong></h5><p>此标签解决了容器的依赖、启动先后的问题</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">'3'</span></span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">      - redis</span><br><span class="line">  redis:</span><br><span class="line">    image: redis</span><br><span class="line">  db:</span><br><span class="line">    image: mysql</span><br></pre></td></tr></table></figure><p>使用<code>docker-compose up web</code>启动,会先启动redis和db,再启动web</p><h5 id="links"><a href="#links" class="headerlink" title="links"></a><strong>links</strong></h5><p>链接到其它服务的中的容器, 与<code>link</code>连接一样效果，会连接到其它服务中的容器</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">web:</span><br><span class="line">  links:</span><br><span class="line">   - db</span><br><span class="line">   - db:database</span><br><span class="line">   - redis</span><br></pre></td></tr></table></figure><h4 id="案例：python计数应用"><a href="#案例：python计数应用" class="headerlink" title="案例：python计数应用"></a>案例：python计数应用</h4><p>同样的，为了更好的理解docker-compose的语法，我们创建一个基础的小应用来加深理解。</p><p>创建一个Python应用， 使用Flask，将数值记入Redis</p><p>1.建立工程目录并在工程目录里创建Python脚本</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@opszn ~]<span class="comment"># mkdir -p /docker-compose/python_count</span></span><br><span class="line">[root@opszn ~]<span class="comment"># cd /docker-compose/python_count</span></span><br><span class="line">[root@opszn python_count]<span class="comment">#</span></span><br><span class="line"></span><br><span class="line">[root@opszn python_count]<span class="comment"># vim app.py</span></span><br><span class="line">from flask import Flask</span><br><span class="line">from redis import Redis</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">redis = Redis(host=<span class="string">'redis'</span>, port=<span class="number">6379</span>)</span><br><span class="line"></span><br><span class="line">@app.route(<span class="string">'/'</span>)</span><br><span class="line">def hello():</span><br><span class="line">    redis.incr(<span class="string">'hits'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello World! I have been seen %s times.'</span> % redis.get(<span class="string">'hits'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app.run(host=<span class="string">"0.0.0.0"</span>, debug=True)</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@opszn python_count]<span class="comment"># vim requirements.txt</span></span><br><span class="line">flask</span><br><span class="line">redis</span><br></pre></td></tr></table></figure><p>2.创建 Dockerfile<br>在同一目录下，创建Dockerfile</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@opszn python_count]<span class="comment"># vim Dockerfile</span></span><br><span class="line">FROM python:<span class="number">2.7</span></span><br><span class="line">ADD . /code</span><br><span class="line">WORKDIR /code</span><br><span class="line">RUN pip install -r requirements.txt</span><br><span class="line">CMD python app.py</span><br></pre></td></tr></table></figure><p>说明: </p><ul><li>容器使用Python 2.7的镜像</li><li>将当前目录下文件拷贝到容器内/code</li><li>指定工作目录为/code</li><li>安装python需要的库：flask, redis,flask默认为5000端口</li><li>容器执行命令 :python app.py</li></ul><p>3.创建编排脚本<br>在同一目录下，创建 docker-compose.yml</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@opszn python_count]# vim docker-compose.yml</span><br><span class="line">version: '3'</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">     - "5000:5000"</span><br><span class="line">    volumes:</span><br><span class="line">     - .:/code</span><br><span class="line">    depends_on:</span><br><span class="line">     - redis</span><br><span class="line">  redis:</span><br><span class="line">    image: redis:latest</span><br></pre></td></tr></table></figure><p>说明:</p><ul><li>这个应用定义了两个服务：web, redis</li><li>web容器通过当前路径下的Dockerfile生成</li><li>web容器内的5000端口映射到docker宿主机的5000端口</li><li>将当前目录挂载到web容器内/code</li><li>web容器依赖于redis容器</li><li>redis容器使用redis:latest镜像启动</li></ul><p>4, 启动应用<br>执行编排脚本，分别制作和拉取web，redis镜像，启动容器</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@opszn python_count]<span class="comment"># docker-compose up -d</span></span><br></pre></td></tr></table></figure><p>5, 访问http://<code>docker宿主机IP</code>:5000，验证计数功能</p><h3 id="docker-swarm"><a href="#docker-swarm" class="headerlink" title="docker-swarm"></a>docker-swarm</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>Docker Swarm是Docker官方提供的一款集群管理工具，其主要作用是把若干台Docker主机抽象为一个整体，并且通过一个入口统一管理这些Docker主机上的各种Docker资源。Swarm和Kubernetes比较类似，但是更加轻，具有的功能也较kubernetes更少一些。</p><ul><li>是docker host集群管理工具</li><li>docker官方提供的</li><li>docker 1.12版本以后</li><li>用来统一集群管理的，把整个集群资源做统一调度</li><li>比kubernetes要轻量化</li><li>实现scaling 规模扩大或缩小</li><li>实现rolling update 滚动更新或版本回退</li><li>实现service discovery 服务发现</li><li>实现load balance 负载均衡</li><li>实现route mesh 路由网格，服务治理</li></ul><h4 id="概念与架构"><a href="#概念与架构" class="headerlink" title="概念与架构"></a>概念与架构</h4><p><strong>节点 (node):</strong> 就是一台docker host上面运行了docker engine.节点分为两类:</p><ul><li>管理节点(manager node) 负责管理集群中的节点并向工作节点分配任务</li><li>工作节点(worker node) 接收管理节点分配的任务，运行任务</li></ul><p><strong>服务(services):</strong> 在工作节点运行的，由多个任务共同组成</p><p><strong>任务(task):</strong> 运行在工作节点上容器或容器中包含应用，是集群中调度最小管理单元</p><p>![](docker容器3/docker swarm架构图.png)</p><h4 id="集群基础应用"><a href="#集群基础应用" class="headerlink" title="集群基础应用"></a>集群基础应用</h4><h5 id="镜像准备"><a href="#镜像准备" class="headerlink" title="镜像准备"></a>镜像准备</h5><p>我们可以构建两个不同的nginx版本推送到仓库中。</p><h5 id="发布服务"><a href="#发布服务" class="headerlink" title="发布服务"></a>发布服务</h5><p>在docker swarm中,对外暴露的是服务（service)，而不是容器。</p><p>为了保持高可用架构，它准许同时启动多个容器共同支撑一个服务，如果一个容器挂了，它会自动使用另一个容器</p><p>在管理节点（manager node）上操作</p><p>1.使用<code>docker service ls</code>查看没有任何服务</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@vm1 ~]<span class="comment"># docker service ls</span></span><br><span class="line">ID       NAME         MODE        REPLICAS       IMAGE         PORTS</span><br></pre></td></tr></table></figure><p>2.发布服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@vm1 ~]# docker service create --replicas 2 --publish 80:80 --name nginx_service 192.168.122.18/library/nginx:v1</span><br><span class="line">6q00dbum7f92wjnrjtnsab225</span><br><span class="line">overall progress: 2 out of 2 tasks</span><br><span class="line">1/2: running   [==================================================&gt;]</span><br><span class="line">2/2: running   [==================================================&gt;]</span><br><span class="line">verify: Service converged</span><br></pre></td></tr></table></figure><p>说明:</p><ul><li>创建一个服务,名为nginx_service</li><li>replicas 2指定2个副本(实现高可用，因为副本期望值)</li><li>–publish 80:80  将服务内部的80端口发布到外部网络(在这里就是192.168.122.0/24网络)的80端口</li><li>使用的镜像为<code>192.168.122.18/library/nginx:v1</code></li></ul><p>3.再次使用<code>docker service ls</code>查看就有服务了</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@vm1 ~]<span class="comment"># docker service ls</span></span><br><span class="line">ID                  NAME                MODE                REPLICAS            IMAGE                             PORTS</span><br><span class="line"><span class="number">6</span>q00dbum7f92        nginx_service       replicated          <span class="number">2</span>/<span class="number">2</span>                 <span class="number">192.168</span>.<span class="number">122.18</span>/library/nginx:v1   *:<span class="number">80</span>-&gt;<span class="number">80</span>/tcp</span><br></pre></td></tr></table></figure><p>4.查看服务运行在哪些节点</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@vm1 ~]<span class="comment"># docker service ps nginx_service</span></span><br><span class="line">ID                  NAME                IMAGE                             NODE                DESIRED STATE       CURRENT STATE           ERROR               PORTS</span><br><span class="line">xxoqft3vp6zm        nginx_service.<span class="number">1</span>     <span class="number">192.168</span>.<span class="number">122.18</span>/library/nginx:v1   vm2.cluster.com     Running             Running <span class="number">3</span> minutes ago</span><br><span class="line">fycl30fuvp9i        nginx_service.<span class="number">2</span>     <span class="number">192.168</span>.<span class="number">122.18</span>/library/nginx:v1   vm1.cluster.com     Running             Running <span class="number">4</span> minutes ago</span><br><span class="line"></span><br><span class="line">可以看到在vm1和vm2节点,可以在vm1和vm2上使用docker ps -a验证</span><br></pre></td></tr></table></figure><h5 id="路由网格"><a href="#路由网格" class="headerlink" title="路由网格"></a>路由网格</h5><p><code>route mesh</code></p><p>假设集群中三个节点，master，node1，node2.我们的容器只运行在了master和node2，但是我们访问node3 的页面也可以成功， 这就是因为路由网格。</p><p><strong>路由网格使得集群中每个节点都能够接收集群中已发布的服务端口的连接，即使节点上没有运行该任务。</strong></p><h5 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h5><p>我们可以通过修改不同容器上的index.html文件内容，再有集群外的节点进行访问，可以发现其具有负载均衡，默认具体的负载均衡算法未知。</p><h5 id="扩展服务"><a href="#扩展服务" class="headerlink" title="扩展服务"></a>扩展服务</h5><p>使用scale指定副本数来扩展(manage node上操作)</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@vm1 ~]<span class="comment"># docker service scale nginx_service=3</span></span><br><span class="line">nginx_service scaled to <span class="number">3</span></span><br><span class="line">overall progress: <span class="number">3</span> out of <span class="number">3</span> tasks</span><br><span class="line"><span class="number">1</span>/<span class="number">3</span>: running   [==================================================&gt;]</span><br><span class="line"><span class="number">2</span>/<span class="number">3</span>: running   [==================================================&gt;]</span><br><span class="line"><span class="number">3</span>/<span class="number">3</span>: running   [==================================================&gt;]</span><br><span class="line">verify: Service converged</span><br></pre></td></tr></table></figure><p>验证</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@vm1 ~]<span class="comment"># docker service ps nginx_service</span></span><br><span class="line">ID                  NAME                IMAGE                             NODE                DESIRED STATE       CURRENT STATE            ERROR               PORTS</span><br><span class="line">xxoqft3vp6zm        nginx_service.<span class="number">1</span>     <span class="number">192.168</span>.<span class="number">122.18</span>/library/nginx:v1   vm2.cluster.com     Running             Running <span class="number">15</span> minutes ago</span><br><span class="line">fycl30fuvp9i        nginx_service.<span class="number">2</span>     <span class="number">192.168</span>.<span class="number">122.18</span>/library/nginx:v1   vm1.cluster.com     Running             Running <span class="number">16</span> minutes ago</span><br><span class="line"><span class="number">0</span>owxm8ykuxcj        nginx_service.<span class="number">3</span>     <span class="number">192.168</span>.<span class="number">122.18</span>/library/nginx:v1   vm3.cluster.com     Running             Running <span class="number">8</span> minutes ago</span><br><span class="line"></span><br><span class="line">可以看到<span class="number">3</span>个节点,使用docker ps -a去<span class="number">3</span>个节点上验证</span><br></pre></td></tr></table></figure><h5 id="裁减服务"><a href="#裁减服务" class="headerlink" title="裁减服务"></a>裁减服务</h5><p>使用scale指定副本数来裁减(manage node上操作)</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@vm1 ~]<span class="comment"># docker service scale nginx_service=1</span></span><br><span class="line">nginx_service scaled to <span class="number">1</span></span><br><span class="line">overall progress: <span class="number">1</span> out of <span class="number">1</span> tasks</span><br><span class="line"><span class="number">1</span>/<span class="number">1</span>: running   [==================================================&gt;]</span><br><span class="line">verify: Service converged</span><br></pre></td></tr></table></figure><p>验证</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@vm1 ~]<span class="comment"># docker service ps nginx_service</span></span><br><span class="line">ID                  NAME                IMAGE                             NODE                DESIRED STATE       CURRENT STATE            ERROR               PORTS</span><br><span class="line">xxoqft3vp6zm        nginx_service.<span class="number">1</span>     <span class="number">192.168</span>.<span class="number">122.18</span>/library/nginx:v1   vm2.cluster.com     Running             Running <span class="number">18</span> minutes ago</span><br><span class="line"></span><br><span class="line">只有vm2上跑有相关容器了</span><br></pre></td></tr></table></figure><h5 id="版本更新或版本回退"><a href="#版本更新或版本回退" class="headerlink" title="版本更新或版本回退"></a>版本更新或版本回退</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@vm1 ~]<span class="comment"># docker service update --image 192.168.122.18/library/nginx:v2 nginx_service</span></span><br><span class="line">nginx_service</span><br><span class="line">overall progress: <span class="number">1</span> out of <span class="number">1</span> tasks</span><br><span class="line"><span class="number">1</span>/<span class="number">1</span>: running   [==================================================&gt;]</span><br><span class="line">verify: Service converged</span><br></pre></td></tr></table></figure><p>说明:</p><ul><li>update代表更新，rollback代表回退</li><li>–image指定要更新的镜像</li><li>nginx_service为指定要更新的服务名称</li></ul><h5 id="滚动间隔更新"><a href="#滚动间隔更新" class="headerlink" title="滚动间隔更新"></a>滚动间隔更新</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@vm1 ~]<span class="comment"># docker service update --replicas 3 --image 192.168.122.18/library/nginx:v2 --update-parallelism 1 --update-delay 30s nginx_service</span></span><br></pre></td></tr></table></figure><p>说明:</p><ul><li>–update-parallelism 1指定并行更新数量</li><li>–update-delay 30s指定更新间隔时间</li></ul><p><strong>注意:</strong> docker swarm滚动更新会造成节点上有exit状态的容器,可以考虑清除</p><h5 id="服务删除"><a href="#服务删除" class="headerlink" title="服务删除"></a>服务删除</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@vm1 ~]<span class="comment"># docker service rm nginx_service</span></span><br><span class="line">nginx_service</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@vm1 ~]<span class="comment"># docker service ls</span></span><br><span class="line">ID       NAME        MODE         REPLICAS       IMAGE       PORTS</span><br></pre></td></tr></table></figure><h5 id="本地存储卷"><a href="#本地存储卷" class="headerlink" title="本地存储卷"></a>本地存储卷</h5><p>用于持久化数据</p><p>思路：</p><p>1.集群内节点都需要创建需要挂载的数据目录</p><p>2.发布服务，将其挂载至需要的位置</p><p>问题：</p><p>上述的思路中，我们是利用本地挂载得到方式实现数据持久化。但如果集群节点较多，那么每次部署就显得非常麻烦，而且各个节点的数据一不一致，不符合实际的业务需求。</p><p>解决的思路：我们可以通过nfs，ceph等远程存储将其挂载至容器需求的位置。</p><h5 id="网络存储卷"><a href="#网络存储卷" class="headerlink" title="网络存储卷"></a>网络存储卷</h5><ul><li>网络存储卷可以实现跨docker宿主机的数据共享,数据持久保存到网络存储卷中</li><li>在创建service时添加卷的挂载参数,网络存储卷可以帮助自动挂载(<strong>但需要集群节点都创建该网络存储卷</strong>)</li></ul><p>思路（nfs）：</p><p>1.所有节点安装nfs客户端。</p><p>2.在远程搭建nfs服务。</p><p>3.docker-swarm集群中创建存储卷。</p><p>4.管理节点发布服务，使用3 中创建的存储卷。</p><p>5.修改远程挂载目录内容， 在集群中验证数据一致性。</p><h5 id="服务互联与服务发现"><a href="#服务互联与服务发现" class="headerlink" title="服务互联与服务发现"></a>服务互联与服务发现</h5><p>如果一个nginx服务与一个mysql服务之间需要连接,在docker swarm如何实现呢?</p><p><strong>方法1:</strong></p><p>把mysql服务也使用 <code>--publish</code>参数发布到外网,但这样做的缺点是:mysql这种服务发布到外网不安全</p><p><strong>方法2:</strong></p><p>将mysql服务等运行在内部网络,只需要nginx服务能够连接mysql就可以了,在docker swarm中可以使用<strong>overlay</strong>网络来实现(overlay就类似在openstack里使用vxlan实现的自助网络)</p><p>但现在还有个问题,服务副本数发生变化时,容器内部的IP发生变化时,我们希望仍然能够访问到这个服务, 这就是<strong>服务发现（service discovery)</strong>.</p><p><strong>通过服务发现, service的使用者都不需要知道service运行在哪里,IP是多少,有多少个副本,就能让service通信</strong></p><p>下面使用<code>docker network ls</code>查看到的ingress网络就是一个overlay类型的网络,但它不支持服务发现</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@vm1 ~]<span class="comment"># docker network ls</span></span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">f1cd139a3cab        bridge              bridge              local</span><br><span class="line">d65ee76360c1        docker_gwbridge     bridge              local</span><br><span class="line"><span class="number">9</span>cc272e76614        host                host                local</span><br><span class="line"><span class="number">1</span>mgiyesumvf6        ingress             overlay             swarm</span><br><span class="line"><span class="number">4824</span>db275540        none                null                local</span><br></pre></td></tr></table></figure><p>我们<strong>需要自建一个overlay网络来实现服务发现, 需要相互通信的service也必须属于同一个overlay网络</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@vm1 ~]<span class="comment"># docker network create --driver overlay --subnet 192.168.100.0/24 self-network</span></span><br></pre></td></tr></table></figure><p>说明:</p><ul><li>–driver overlay指定为overlay类型</li><li>–subnet 分配网段</li><li>self-network  为自定义的网络名称</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@vm1 ~]<span class="comment"># docker network ls</span></span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">f1cd139a3cab        bridge              bridge              local</span><br><span class="line">d65ee76360c1        docker_gwbridge     bridge              local</span><br><span class="line"><span class="number">9</span>cc272e76614        host                host                local</span><br><span class="line"><span class="number">1</span>mgiyesumvf6        ingress             overlay             swarm</span><br><span class="line"><span class="number">4824</span>db275540        none                null                local</span><br><span class="line">d9l9885takmm        self-network        overlay             swarm</span><br></pre></td></tr></table></figure><p>我们需要在创建服务的时候将网络类型指定为上面我们创建的网络。</p><p><strong>结论: 在自建的overlay网络内,通过服务发现可以实现服务之间通过服务名(不用知道对方的IP)互联,而且不会受服务内副本个数和容器内IP变化等的影响。</strong></p><h3 id="docker-stack"><a href="#docker-stack" class="headerlink" title="docker-stack"></a>docker-stack</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>早期使用service发布，每次只能发布一个service。</p><p>yaml可以发布多个服务，但是使用docker-compose只能在一台主机发布。</p><p>一个stack就是一组有关联的服务的组合，可以一起编排，一起发布, 一起管理</p><ul><li>docker stack deploy       部署新的堆栈或更新现有堆栈</li><li>docker stack ls                列出现有堆栈</li><li>docker stack ps              列出堆栈中的任务</li><li>docker stack rm             删除一个或多个堆栈</li><li>docker stack services    列出堆栈中的服务</li></ul><h4 id="案例实现：wordpress"><a href="#案例实现：wordpress" class="headerlink" title="案例实现：wordpress"></a>案例实现：wordpress</h4><ul><li><p>编写yaml文件</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@vm1 ~]<span class="comment"># vim stack1.yml</span></span><br><span class="line">version: <span class="string">'3'</span></span><br><span class="line">services:</span><br><span class="line">  db:</span><br><span class="line">    image: mysql:<span class="number">5.7</span></span><br><span class="line">    environment:</span><br><span class="line">      MYSQL_ROOT_PASSWORD: wordpress</span><br><span class="line">      MYSQL_DATABASE: wordpress</span><br><span class="line">      MYSQL_USER: wordpress</span><br><span class="line">      MYSQL_PASSWORD: wordpress</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  wordpress:</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">    image: wordpress:latest</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">"8010:80"</span></span><br><span class="line">    environment:</span><br><span class="line">      WORDPRESS_DB_HOST: db:<span class="number">3306</span></span><br><span class="line">      WORDPRESS_DB_PASSWORD: wordpress</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: <span class="number">1</span></span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role == manager]</span><br></pre></td></tr></table></figure><p>说明：placement的constraints限制此容器在manager节点</p></li><li><p>使用docker stack 发布</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@vm1 ~]<span class="comment"># docker stack deploy -c stack1.yml stack1</span></span><br><span class="line">Creating network stack1_default创建自建的overlay网络</span><br><span class="line">Creating service stack1_db创建stack1_db服务</span><br><span class="line">Creating service stack1_wordpress创建stack1_wordpress服务</span><br></pre></td></tr></table></figure></li><li><p>在浏览器使用管理节点IP进行访问</p></li></ul><h4 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h4><p>万一在stack 发布的时候出现错误，我们要对已经构建的stack1进行删除，而后在排查问题，重新发布。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;docker容器3&quot;&gt;&lt;a href=&quot;#docker容器3&quot; class=&quot;headerlink&quot; title=&quot;docker容器3&quot;&gt;&lt;/a&gt;docker容器3&lt;/h1&gt;&lt;h2 id=&quot;docker三剑客介绍&quot;&gt;&lt;a href=&quot;#docker三剑客介绍&quot; c
      
    
    </summary>
    
      <category term="容器" scheme="https://www.opszn.com/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="docker" scheme="https://www.opszn.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker容器2</title>
    <link href="https://www.opszn.com/2019/03/22/docker%E5%AE%B9%E5%99%A82/"/>
    <id>https://www.opszn.com/2019/03/22/docker容器2/</id>
    <published>2019-03-22T01:48:20.000Z</published>
    <updated>2019-08-16T07:52:58.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="docker容器2"><a href="#docker容器2" class="headerlink" title="docker容器2"></a>docker容器2</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上次的文章中，我们主要对于docker进行了简单的介绍，同时与传统虚拟化技术的区别与优势。还对docker镜像常见的操作进行了简单的介绍，也拓展了几种仓库方便我们灵活根据各自特点进行选择。</p><h2 id="容器常见的操作"><a href="#容器常见的操作" class="headerlink" title="容器常见的操作"></a>容器常见的操作</h2><table><thead><tr><th>docker ps -a</th><th>列出本地的所有容器信息</th></tr></thead><tbody><tr><td>docker attach 容器名/id</td><td>连接一个UP状态的容器,可以进去交互(有bash环境的才可以)</td></tr><tr><td>docker run 参数选项 –name 容器名 镜像名:TAG</td><td>传给容器内部执行的命令</td></tr><tr><td>docker log 容器名/id</td><td>输出容器内执行命令的结果</td></tr><tr><td>docker stop 容器名/id</td><td>停止容器</td></tr><tr><td>docker start 容器名/id</td><td>启动容器</td></tr><tr><td>docker inspect 容器名/id</td><td>查看容器相关信息</td></tr><tr><td>docker exec 容器名/id</td><td>在容器外指定容器执行命令</td></tr><tr><td>docker rm 容器名/id</td><td>删除容器（up状态的容器要先stop停止）</td></tr><tr><td>docker commit 容器名/id 新的镜像名:TAG</td><td>将容器提交为一个镜像</td></tr></tbody></table><h3 id="运行一个测试容器"><a href="#运行一个测试容器" class="headerlink" title="运行一个测试容器"></a>运行一个测试容器</h3><p>通过hello-world这个镜像,运行一个容器(没有定义容器名称,则为随机名称)</p><ul><li>当前docker-host(容器宿主机)如果有hello-world这个镜像,则直接使用</li><li>如果没有相关镜像,则会从docker hub去下载(配置了镜像加速器的优先找加速器)</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@opszn ~]<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMES</span><br><span class="line"><span class="number">6</span>e3f991b9e8a        hello-world         <span class="string">"/hello"</span>            <span class="number">3</span> minutes ago       Exited (<span class="number">0</span>) <span class="number">2</span> minutes ago                       silly_lovelace</span><br><span class="line"></span><br><span class="line">上面列表格式比较长，看起来有些不舒服。可以简单处理下,只查看重要的几列</span><br><span class="line">[root@opszn ~]<span class="comment"># docker ps -a |awk -F"[  ]&#123;2&#125;*" '&#123;print $1"\t\t"$3"\t\t"$5"\t"$NF&#125;'</span></span><br><span class="line">CONTAINER ID COMMAND STATUSNAMES</span><br><span class="line"><span class="number">6</span>e3f991b9e8a <span class="string">"/hello"</span> Exited (<span class="number">0</span>) <span class="number">3</span> minutes agosilly_lovelace</span><br></pre></td></tr></table></figure><p>问题: 为什么容器运行完hello-world后就退出了,而不是继续运行?</p><p>我们前面把容器比喻为轻量级虚拟机,但是容器实际上只是<strong>==进程==</strong>。进行运行完了当然就退出了, 除非是类似服务那样的守护进程。</p><h3 id="容器交互"><a href="#容器交互" class="headerlink" title="容器交互"></a>容器交互</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">使用下面命令启动容器;-i指交互;-t指tty终端;--name是用来指定容器名称</span><br><span class="line">[root@opsznl ~]<span class="comment"># docker run -i -t --name=c1 centos:latest /bin/bash</span></span><br><span class="line">[root@f736fe36002c /]<span class="comment"># cat /etc/redhat-release </span></span><br><span class="line">CentOS Linux release <span class="number">7.6</span>.<span class="number">1810</span> (Core) 可以看到我们下载的centos是<span class="number">7.6</span>版本</span><br><span class="line">[root@f736fe36002c /]<span class="comment"># uname -r</span></span><br><span class="line"><span class="number">3.10</span>.<span class="number">0</span>-<span class="number">862</span>.el7.x86_64查看的内核却与宿主机centos7.<span class="number">5</span>一样,说明是共享宿主机的内核</span><br><span class="line"></span><br><span class="line">在容器内操作(我这里创建一个文件，然后退出)</span><br><span class="line">[root@f736fe36002c /]<span class="comment"># touch /root/opszn</span></span><br><span class="line">[root@f736fe36002c /]<span class="comment"># exit</span></span><br><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure><h2 id="docker存储驱动"><a href="#docker存储驱动" class="headerlink" title="docker存储驱动"></a>docker存储驱动</h2><h3 id="写时复制与用时分配"><a href="#写时复制与用时分配" class="headerlink" title="写时复制与用时分配"></a>写时复制与用时分配</h3><p>通过之前的了解我们已经知道，一个镜像可以跑多个容器。但是如果每一个容器都去复制一份完整的镜像文件，那么将会占用大量的存储空间。docker使用了写时复制<strong>cow(copy-on-write)</strong>与用时分配<strong>aod(allocate-on-demand)</strong>技术用来提高存储的利用率。</p><p><strong>写时复制</strong>: </p><ul><li><p>写时复制技术可以让多个容器共享同一个镜像的文件系统, 所有数据都从镜像中读取</p></li><li><p>只有当要对文件进行写操作时，才从镜像里把要写的文件复制到自己的文件系统进行修改。所以无论有多少</p><p>个容器共享同一个镜像，所做的写操作都是对从镜像中复制到自己的文件系统中的复本上进行，并不会修</p><p>改镜像的源文件</p></li><li><p>多个容器操作同一个文件，会在每个容器的文件系统里生成一个复本，每个容器修改的都是自己的复本，相互隔离，相互不影响</p></li></ul><p><strong>用时分配:</strong></p><p>启动一个容器，并不会为这个容器预分配一些磁盘空间，而是当有新文件写入时，才按需分配新空间</p><h3 id="联合文件系统"><a href="#联合文件系统" class="headerlink" title="联合文件系统"></a>联合文件系统</h3><p>联合文件系统(UnionFS)就是把不同物理位置的目录合并mount到同一个目录中.</p><p>比如你可以将一个光盘与一个硬盘上的目录联合挂载到一起,然后对只读的光盘文件进行修改,修改的文件不存放回光盘进行覆盖,而是存放到硬盘目录。这样做达到了不影响光盘原数据,而修改的目的。</p><p><strong>把光盘看作是docker里的image,而硬盘目录看作是container,就不难理解了</strong></p><p>docker支持aufs和overlay两种联合文件系统。下面我们来看一下这两种文件系统。</p><h4 id="aufs"><a href="#aufs" class="headerlink" title="aufs"></a>aufs</h4><p>Docker最开始采用AUFS作为文件系统，也得益于AUFS分层的概念，实现了多个Container可以共享同一个image。</p><p>aufs(Another UnionFS)，后来叫Alternative UnionFS，后来可能觉得不够霸气，叫成Advance UnionFS.</p><p>Docker最开始采用AUFS作为文件系统，也得益于AUFS分层的概念，实现了多个Container可以共享同一个image</p><p><strong>除了最上面的一层为读写层之外，下面的其他的层都是只读的镜像层</strong></p><p><img src="/2019/03/22/docker容器2/aufs%E5%88%86%E5%B1%82%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt></p><h4 id="overlay"><a href="#overlay" class="headerlink" title="overlay"></a>overlay</h4><p>由于AUFS未并入Linux内核，且只支持Ubuntu，考虑到兼容性问题，在Docker 0.7版本中引入了存储驱动。 目前，Docker支持AUFS,OverlayFS,Btrfs,Device mapper,ZFS五种存储驱动.</p><p>目前, 在ubuntu发行版上默认存储方式为AUFS,CentOS发行版上的默认存储方式为Overlay或Overlay2</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker info |grep "Storage Driver"</span></span><br><span class="line">Storage Driver: overlay2</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># lsmod |egrep 'aufs|overlay'</span></span><br><span class="line">overlay                <span class="number">71964</span>  <span class="number">7</span></span><br></pre></td></tr></table></figure><p>centos上加载了overlay模块,从3.18版本内核开始,就进入了Linux内核主线</p><p>Overlay是Linux内核3.18后支持的(当前3.10内核加载模块也可以使用),也是一种Union FS,和AUFS的多层不同的是Overlay只有两层：一个upper文件系统和一个lower文件系统，分别代表Docker的容器层和镜像层..</p><p>OverlayFS底层目录称为lowerdir,高层目录称为upperdir。合并统一视图称为merged。当需要修改一个文件时，使用cow将文件从只读的Lower复制到可写的Upper进行修改，结果也保存在Upper层。在Docker中，底下的只读层就是image，可写层就是Container</p><p>下图分层图，镜像层是lowdir，容器层是upperdir,统一的视图层是merged层. </p><p>视图层就是给用户提供了一个统一的视角，隐藏了多个层的复杂性，对用户来说只存在一个文件系统。</p><p><img src="/2019/03/22/docker容器2/overlay%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt></p><p>从上图中可以看到: </p><ul><li>如果upperdir和lowerdir有同名文件时会用upperdir的文件 </li><li>读文件的时候，文件不在upperdir则从lowerdir读</li><li>如果写的文件不在uppderdir在lowerdir,则从lowerdir里面copy到upperdir。</li><li>不管文件多大,copy完再写,删除或者重命名镜像层的文件都只是在容器层生成whiteout文件标志(标记为删除,并不是真的删除)</li></ul><h4 id="aufs-overlay-overlay2对比"><a href="#aufs-overlay-overlay2对比" class="headerlink" title="aufs,overlay,overlay2对比"></a>aufs,overlay,overlay2对比</h4><table><thead><tr><th>aufs</th><th>使用多层分层</th></tr></thead><tbody><tr><td>overlay</td><td>使用2层分层, 共享数据方式是通过<strong>硬连接</strong>，只挂载一层,其他层通过最高层通过硬连接形式共享(<strong>增加了磁盘inode的负担</strong>)</td></tr><tr><td>overlay2</td><td>使用2层分层, 驱动原生地支持多层lower overlay镜像(最多128层),与overlay驱动对比,消耗更少的inode</td></tr></tbody></table><h4 id="简单验证"><a href="#简单验证" class="headerlink" title="简单验证"></a>简单验证</h4><p>我们使用一台新的服务器安装docker，看一下/var/lib下并没有docker这个目录，然后启动docker后就有了</p><ul><li><p>启动后进入/var/lib/docker/overlay2/查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@vm2 ~]# cd /var/lib/docker/overlay2/</span><br><span class="line">[root@vm2 overlay2]# ls</span><br><span class="line">total 0</span><br><span class="line">brw------- 1 root root 8, 3 Jul 26 14:10 backingFsBlockDev</span><br><span class="line">drwx------ 2 root root    6 Jul 26 14:10 l</span><br></pre></td></tr></table></figure></li><li><p>我们下载一个镜像后再次查看</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">root@vm2 overlay2]<span class="comment"># pwd</span></span><br><span class="line">/var/lib/docker/overlay2</span><br><span class="line">[root@vm2 overlay2]<span class="comment"># ls</span></span><br><span class="line"><span class="number">23664</span>d7a4167e74ee04838d87cd3568cc82be49f781bba2212b9bff942bb8fa4  backingFsBlockDev  l</span><br><span class="line"></span><br><span class="line">[root@vm2 overlay2]<span class="comment"># ls 23664d7a4167e74ee04838d87cd3568cc82be49f781bba2212b9bff942bb8fa4/</span></span><br><span class="line">diff  link</span><br><span class="line"></span><br><span class="line">[root@vm2 overlay2]<span class="comment"># ls 23664d7a4167e74ee04838d87cd3568cc82be49f781bba2212b9bff942bb8fa4/diff/</span></span><br><span class="line">anaconda-post.log  bin  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line"></span><br><span class="line">[root@vm2 overlay2]<span class="comment"># cat 23664d7a4167e74ee04838d87cd3568cc82be49f781bba2212b9bff942bb8fa4/link</span></span><br><span class="line"><span class="number">5</span>D7D6BY2V3FKMZHUU6VHK7ILWL</span><br><span class="line"></span><br><span class="line">[root@vm2 overlay2]<span class="comment"># ll l</span></span><br><span class="line">total <span class="number">0</span></span><br><span class="line">lrwxrwxrwx <span class="number">1</span> root root <span class="number">72</span> Jul <span class="number">26</span> <span class="number">14</span>:<span class="number">16</span> <span class="number">5</span>D7D6BY2V3FKMZHUU6VHK7ILWL -&gt; ../<span class="number">23664</span>d7a4167e74ee04838d87cd3568cc82be49f781bba2212b9bff942bb8fa4/diff</span><br></pre></td></tr></table></figure></li><li><p>小结</p><p>1.下载完镜像,overlay2目录里多了一个<code>23664....</code>这样的目录,只有1层</p><p>2.此目录内部的diff子目录记录每一层自己的数据</p><p>3.link记录该层链接目录(和overlay目录下l子目录里记录的链接是一致的)</p><p>4.子目录中包含了很多软链接，使用短名称指向了其他层，短名称用于避免mount参数时达到页面大小的限制</p></li></ul><h2 id="容器运行应用"><a href="#容器运行应用" class="headerlink" title="容器运行应用"></a>容器运行应用</h2><p>前面我们熟悉了容器的常见操作，但容器中并没有跑过应用程序.而生产环境是要用容器来跑应用程序的。</p><p>在<strong>宿主机上打开ip_forward</strong>, 因为我们下面要映射容器的端口到宿主机,只有打开ip_forward才能映射成功</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@opszn ~]<span class="comment"># vim /etc/sysctl.conf</span></span><br><span class="line">net.ipv4.ip_forward = <span class="number">1</span></span><br><span class="line">[root@opszn ~]<span class="comment"># sysctl -p</span></span><br></pre></td></tr></table></figure><h3 id="运行一个httpd"><a href="#运行一个httpd" class="headerlink" title="运行一个httpd"></a>运行一个httpd</h3><h4 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h4><p>利用官方centos镜像运行容器跑httpd服务,因为官方centos镜像里默认并没有安装httpd服务,所以需要我们自定义安装</p><p>1.docker内部跑httpd启动80端口,需要与docker_host(宿主机)进行端口映射,才能让客户端通过网络来访问</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@opszn ~]<span class="comment"># docker run -it -p 8000:80 --name=httpd1 centos:latest /bin/bash</span></span><br><span class="line">[root@b0a9623d3920 /]<span class="comment"># yum install httpd httpd-devel -y</span></span><br><span class="line">Failed to get D-Bus connection: Operation not permitted</span><br><span class="line">启动服务.这里用echo opszn &gt; /var/www/html/index.html启动服务会报错，所以直接使用命令启动</span><br><span class="line">[root@b0a9623d3920 /]<span class="comment"># httpd -k start</span></span><br><span class="line">[root@b0a9623d3920 /]<span class="comment"># ss -an |grep :80</span></span><br><span class="line">tcp    LISTEN     <span class="number">0</span>      <span class="number">0</span>        :::<span class="number">80</span>                   :::*</span><br></pre></td></tr></table></figure><p>2.这里如果exit退出的话,启动的服务也会关闭。同时按下<strong>ctrl+q+p</strong>三键，可以实现退出容器并保持容器<strong>后台运行</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">可以查看到容器仍然是UP状态</span><br><span class="line">[root@opszn ~]<span class="comment"># docker ps -l</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                  NAMES</span><br><span class="line">b0a9623d3920        centos:latest       <span class="string">"/bin/bash"</span>         <span class="number">1</span> minutes ago      Up <span class="number">1</span> minutes       <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">8000</span>-&gt;<span class="number">80</span>/tcp   httpd1</span><br></pre></td></tr></table></figure><p>3.使用另一台机器浏览器访问 <strong>http://宿主机IP:8000</strong>测试</p><h4 id="自定义httpd并提交为镜像"><a href="#自定义httpd并提交为镜像" class="headerlink" title="自定义httpd并提交为镜像"></a>自定义httpd并提交为镜像</h4><p>cenots镜像里并没有httpd,所以需要安装.但是如果每次启动一个容器都要安装一遍httpd是让人受不了的.所以我们在一个容器里安装一次,把想自定义的全做了,然后将此容器commit成一个新的镜像。</p><p>以后就用这个新镜像运行容器就可以不用再重复装环境了。</p><p>1, 运行容器httpd2,安装httpd相关软件并自定义配置</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@opszn ~]<span class="comment"># docker run -it --name=httpd2 centos:latest /bin/bash</span></span><br><span class="line"></span><br><span class="line">[root@<span class="number">82</span>b985aea72c /]<span class="comment"># yum install httpd httpd-devel -y</span></span><br><span class="line"></span><br><span class="line">[root@<span class="number">82</span>b985aea72c /]<span class="comment"># mkdir /www</span></span><br><span class="line">[root@<span class="number">82</span>b985aea72c /]<span class="comment"># echo "main page" &gt; /www/index.html</span></span><br><span class="line"></span><br><span class="line">修改<span class="number">119</span>行和<span class="number">131</span>行的家目录为/www</span><br><span class="line">[root@<span class="number">82</span>b985aea72c /]<span class="comment"># vi /etc/httpd/conf/httpd.conf</span></span><br><span class="line"></span><br><span class="line">[root@<span class="number">82</span>b985aea72c /]<span class="comment"># exit</span></span><br><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure><p>2, exit退出后此容器就变为了Exited状态</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@opszn ~]<span class="comment"># docker ps -l</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMES</span><br><span class="line"><span class="number">82</span>b985aea72c        centos:latest       <span class="string">"/bin/bash"</span>         <span class="number">5</span> minutes ago      Exited (<span class="number">0</span>) <span class="number">6</span> seconds ago                       httpd2</span><br></pre></td></tr></table></figure><p>3, 将搭建好的环境commit成新的镜像(<strong>此镜像相当于是自定义的,生产环境中可以按需求push到镜像仓库</strong>)</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@opszn ~]<span class="comment"># docker commit httpd2 httpd_image</span></span><br></pre></td></tr></table></figure><p>4, 将commit提交的镜像启动一个新的容器,并将端口80映射到宿主机的8001</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@opszn ~]<span class="comment"># docker run -d -p 8001:80 --name=httpd3 httpd_image /usr/sbin/httpd -D FOREGROUND</span></span><br><span class="line">dcaca836b94655364749c064519ad66c8229657262465e7ea8194f2616980b61</span><br><span class="line">[root@opszn ~]<span class="comment"># lsof -i:8001</span></span><br><span class="line">COMMAND     PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</span><br><span class="line">docker-pr <span class="number">23130</span> root    <span class="number">4</span>u  IPv6 <span class="number">183572</span>      <span class="number">0</span>t0  TCP *:vcom-tunnel (LISTEN)</span><br></pre></td></tr></table></figure><p>5, 使用另一台机器浏览器访问 <strong>http://宿主机IP:8001</strong>测试</p><h4 id="数据卷挂载"><a href="#数据卷挂载" class="headerlink" title="数据卷挂载"></a>数据卷挂载</h4><p>当容器删除时,里面的相关数据也会删除,也就是说数据不能持久化保存。</p><p>我们可以将服务的配置文件,数据目录,日志目录等与宿主机的目录映射，把数据保持到宿主机上实现<strong>数据持久化</strong>.</p><p>宿主机的目录也可以共享给多个容器使用。 </p><p><strong>将宿主机的目录(数据卷)挂载到容器中(配置文件也可以挂载)</strong></p><p>1,先在宿主机创建一个目录，并建立一个内容不同的主页</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@opszn ~]<span class="comment"># mkdir /docker_www</span></span><br><span class="line">[root@opszn ~]<span class="comment"># echo opszn &gt; /docker_www/index.html</span></span><br></pre></td></tr></table></figure><p>2,运行容器httpd4, 将宿主机的/docker_www/目录挂载到容器中的/www/目录</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@opszn ~]<span class="comment"># docker run -d -p 8002:80 -v /docker_www/:/www --name=httpd4 httpd_image /usr/sbin/httpd -D FOREGROUND</span></span><br><span class="line"></span><br><span class="line">[root@opszn ~]<span class="comment"># docker ps -l</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                  NAMES</span><br><span class="line"><span class="number">484</span>d7432d7ef        httpd_image         <span class="string">"/usr/sbin/httpd -..."</span>          <span class="number">21</span> seconds ago      Up <span class="number">20</span> seconds       <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">8002</span>-&gt;<span class="number">80</span>/tcp   httpd4</span><br></pre></td></tr></table></figure><p>3, 使用另一台机器浏览器访问 <strong>http://宿主机IP:8002</strong>测试</p><p>(注意: 如果访问不到主页,请检查是否关闭了selinux)</p><p>4, 尝试修改宿主机/docker_www/index.html的内容, 访问的结果也会随着修改而改变</p><h2 id="dockerfile构建镜像"><a href="#dockerfile构建镜像" class="headerlink" title="dockerfile构建镜像"></a>dockerfile构建镜像</h2><p>除了使用docker commit把自定义容器提交成镜像外，还可以使用Dockerfile来构建自定义镜像。</p><blockquote><p>什么是Dockerfile?</p><p>答:  Dockerfile把构建镜像的步骤都写出来,然后按顺序执行实现自动构建镜像。就类似于脚本文件,ansible的playbook,saltstack的sls文件等。</p></blockquote><h3 id="docker指令"><a href="#docker指令" class="headerlink" title="docker指令"></a>docker指令</h3><p>我们可以同过<strong>man docker</strong>来获取命令帮助，</p><p>这里涉及几个常用的命令。</p><h4 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h4><p>FROM用于指定构建新镜像所使用的基础镜像。</p><p>FROM必须是dockerfile文件内的首条命令。</p><p>FROM指定的基础镜像，可以是官网的，云运营商的从，也可以是本地的。优先是本地仓库。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式:FROM &lt;image&gt;:&lt;tag&gt;</span><br><span class="line">例:FROM centos:latest</span><br></pre></td></tr></table></figure><h4 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h4><p>RUN用于构建镜像中执行的命令，有shell和exec两种格式：</p><p><strong>shell</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式:RUN &lt;命令&gt;</span><br><span class="line">例:RUN echo opszn &gt; /var/www/html/index.html</span><br></pre></td></tr></table></figure><p><strong>exec</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式:RUN [<span class="string">"可执行文件"</span>, <span class="string">"参数1"</span>, <span class="string">"参数2"</span>]</span><br><span class="line">例:RUN [<span class="string">"/bin/bash"</span>, <span class="string">"-c"</span>, <span class="string">"echo opszn &gt; /var/www/html/index.html"</span>]</span><br></pre></td></tr></table></figure><p>注意：当我们需要在同一个dockerfile中使用多条命令时，尽量不要使用多条RUN,可以运用<strong>&amp;&amp;</strong>和** \ **符号将多条命令放入单个RUN中。因为我们使用多个RUN会让镜像建立的时候有多层分层（相当于镜像就变得很臃肿）。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RUN yum -y install httpd-devel -y</span><br><span class="line">RUN echo opszn &gt; /var/www/html/index.html</span><br><span class="line"></span><br><span class="line">改写<span class="number">1</span></span><br><span class="line">RUN yum -y install httpd-devel &amp;&amp; echo opszn &gt; /var/www/html/index.html</span><br><span class="line"></span><br><span class="line">改写<span class="number">2</span></span><br><span class="line">RUN yum -y install httpd-devel \ </span><br><span class="line">     &amp;&amp; echo opszn &gt; /var/www/html/index.html</span><br></pre></td></tr></table></figure><h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><p>CMD不同于RUN：CMD指定容器在启动时需要执行的命令；RUN指定容器构建时需要执行的命令。</p><p><strong>三种格式</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CMD [<span class="string">"executable"</span>,<span class="string">"param1"</span>,<span class="string">"param2"</span>]</span><br><span class="line">CMD [<span class="string">"param1"</span>,<span class="string">"param2"</span>]</span><br><span class="line">CMD command <span class="keyword">param</span>1 <span class="keyword">param</span>2</span><br></pre></td></tr></table></figure><p>每个Dockerfile只能有一条CMD命令。如果指定了多条命令，只有最后一条会被执行。</p><p>如果用户启动容器时候指定了运行的命令，则会覆盖掉CMD指定的命令。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">什么是启动容器时指定运行的命令?</span><br><span class="line"><span class="comment">#docker run -d -p 80:80 镜像名 运行的命令</span></span><br></pre></td></tr></table></figure><h4 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h4><p>本指令用于指定容器在启动时坚挺的端口。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式:EXPOSE &lt;port&gt; [&lt;port&gt;...]</span><br><span class="line">例:EXPOSE <span class="number">80</span> <span class="number">3306</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><p>在dockerfile中指定端口后还需要在执行容器启动命令时通过-p参数将端口映射到宿主机的端口。</p><h4 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h4><p>指定环境变量</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式:ENV &lt;key&gt; &lt;value&gt; 或者 ENV &lt;key&gt;=&lt;value&gt;</span><br><span class="line">例:ENV JAVA_HOME /usr/local/jdkxxxx/</span><br></pre></td></tr></table></figure><h4 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h4><p>用于将宿主机的文件拷贝至镜像中</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">格式:ADD &lt;src&gt; &lt;dest&gt;</span><br><span class="line">&lt;src&gt;可以是一个本地文件或本地压缩文件，还可以是一个url,</span><br><span class="line">如果把&lt;src&gt;写成一个url，那么ADD就类似于wget命令</span><br><span class="line">&lt;dest&gt;路径的填写可以是容器内的绝对路径，也可以是相对于工作目录的相对路径</span><br></pre></td></tr></table></figure><h4 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h4><p>COPY指令与ADD指令类似,但COPY的源文件只能是本地文件</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">格式:COPY &lt;src&gt; &lt;dest&gt;</span><br></pre></td></tr></table></figure><h4 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h4><p>ENTRYPOINT与CMD非常类似</p><p>相同点：<br>一个Dockerfile只写一条，如果写了多条，那么只有最后一条生效<br>都是容器启动时才运行</p><p>不同点：<br>如果用户启动容器时候指定了运行的命令，ENTRYPOINT不会被运行的命令覆盖，而CMD则会被覆盖</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">格式有两种:</span><br><span class="line">ENTRYPOINT [<span class="string">"executable"</span>, <span class="string">"param1"</span>, <span class="string">"param2"</span>]</span><br><span class="line">ENTRYPOINT command <span class="keyword">param</span>1 <span class="keyword">param</span>2</span><br></pre></td></tr></table></figure><h4 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a><strong>VOLUME</strong></h4><p>VOLUME指令用于把宿主机里的目录与容器里的目录映射. </p><p>只指定挂载点,docker宿主机映射的目录为自动生成的。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">格式:VOLUME [<span class="string">"&lt;mountpoint&gt;"</span>]</span><br></pre></td></tr></table></figure><h4 id="USER"><a href="#USER" class="headerlink" title="USER"></a><strong>USER</strong></h4><p>USER指令设置启动容器的用户(像hadoop需要hadoop用户操作，oracle需要oracle用户操作),可以是用户名或UID</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">USER daemon</span><br><span class="line">USER <span class="number">1001</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：如果设置了容器以daemon用户去运行，那么RUN,CMD和ENTRYPOINT都会以这个用户去运行<br>镜像构建完成后，通过docker run运行容器时，可以通过-u参数来覆盖所指定的用户</p><h4 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h4><p>指定工作目录，类似于CD命令，不建议使用RUN cd  /etc/ 原因在RUN中提到过。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /root</span><br></pre></td></tr></table></figure><p><strong>步骤：</strong></p><p>1、创建一个文件夹（目录）</p><p>2、在文件夹（目录）中创建Dockerfile文件(并编写)及其它文件</p><p>3、使用<code>docker build</code>命令构建镜像</p><p>4、使用构建的镜像启动容器</p><h3 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h3><p>对于构建镜像我们已经将一些常用的命令进行一个解释了，那么现在呢就通过案例来更加深入的了解一下dockerfile构建镜像的过程。</p><h4 id="httpd镜像实现"><a href="#httpd镜像实现" class="headerlink" title="httpd镜像实现"></a>httpd镜像实现</h4><ul><li><p>宿主机创建一个目录(这里为了查找dockerfile方便，我统一将文件放入这个文件目录中)</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /dockerfile</span><br></pre></td></tr></table></figure></li><li><p>编写dockfile</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@opszn ~]<span class="comment"># cd /dockerfile</span></span><br><span class="line">[root@opszn dockerfile]<span class="comment"># vim dockerfile_httpd </span></span><br><span class="line">FROM     centos</span><br><span class="line"></span><br><span class="line">MAINTAINER opszn</span><br><span class="line"></span><br><span class="line">RUN yum install httpd httpd-devel -y \</span><br><span class="line">&amp;&amp; echo <span class="string">"container main page"</span> &gt; /var/www/html/index.html</span><br><span class="line"></span><br><span class="line">EXPOSE  <span class="number">80</span></span><br><span class="line">CMD [<span class="string">"/usr/sbin/httpd"</span>,<span class="string">"-D"</span>,<span class="string">"FOREGROUND"</span>]</span><br></pre></td></tr></table></figure></li><li><p>使用<code>docker build</code>构建镜像,注意最后有一个点(代表当前目录)</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@opszn dockerfile]<span class="comment"># docker build -f dockerfile_httpd -t my_httpd:v1 .</span></span><br></pre></td></tr></table></figure></li><li><p>验证镜像</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@opszn dockerfile]<span class="comment">#docker images |grep my_httpd</span></span><br><span class="line">my_httpd            v1                  e316739796ae        <span class="number">1</span> minutes ago       <span class="number">348</span> MB</span><br></pre></td></tr></table></figure></li><li><p>使用构建好的镜像创建容器</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@opszn dockerfile]<span class="comment"># docker run -d -p 8005:80 my_httpd:v1</span></span><br><span class="line"></span><br><span class="line">[root@opszn dockerfile]<span class="comment"># docker ps -a |grep my_httpd</span></span><br><span class="line">c539e6161463        my_httpd:v1         <span class="string">"/usr/sbin/httpd -..."</span>   <span class="number">1</span> minutes ago       Up <span class="number">8</span> minutes        <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">8005</span>-&gt;<span class="number">80</span>/tcp   boring_goldstine</span><br></pre></td></tr></table></figure></li><li><p>客户端访问宿主机ip+8005端口验证</p></li></ul><h4 id="mariadb镜像实现"><a href="#mariadb镜像实现" class="headerlink" title="mariadb镜像实现"></a>mariadb镜像实现</h4><p>1, 准备1个脚本执行mysql的初始化与启动</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@opszn dockerfile]<span class="comment"># vim mariadb.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">mysql_install_db --datadir=/var/lib/mysql/ --user=mysql</span><br><span class="line">sleep <span class="number">3</span></span><br><span class="line">mysqld_safe --defaults-file=/etc/my.cnf &amp;</span><br><span class="line">sleep <span class="number">3</span></span><br><span class="line"></span><br><span class="line">mysql -e <span class="string">"grant all privileges on *.* to 'root'@'%' identified by '123';"</span></span><br><span class="line">mysql -e <span class="string">"grant all privileges on *.* to 'abc'@'%' identified by '123';"</span></span><br><span class="line">mysql -e <span class="string">"flush privileges;"</span></span><br></pre></td></tr></table></figure><p>说明: </p><ul><li>使用脚本而不直接使用dockerfile里的RUN指令的原因是: 启动mysql服务需要使用<code>&amp;</code>放到后台,但把后台符号放在RUN里会造成RUN命令有问题,所以单独使用脚本来做</li><li>sleep 3秒是因为初始化和启动服务需要一定的时间,等待3秒缓冲一下</li></ul><p>2, 创建dockerfile</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@opszn dockerfile]<span class="comment"># vim dockerfile_mariadb</span></span><br><span class="line">FROM centos:latest</span><br><span class="line"></span><br><span class="line">MAINTAINER opszn</span><br><span class="line"></span><br><span class="line">RUN rm -rf /etc/yum.repos.d/*</span><br><span class="line">ADD local.repo /etc/yum.repos.d/local.repo</span><br><span class="line">RUN yum install mariadb-server mariadb -y</span><br><span class="line"></span><br><span class="line">COPY mariadb.sh .</span><br><span class="line">RUN sh mariadb.sh</span><br><span class="line"></span><br><span class="line">EXPOSE <span class="number">3306</span></span><br><span class="line">CMD mysqld_safe --defaults-file=/etc/my.cnf</span><br></pre></td></tr></table></figure><p>3, <code>docker build</code></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@opszn dockerfile]<span class="comment"># docker build -f dockerfile_mariadb -t my_mariadb:v1 .</span></span><br></pre></td></tr></table></figure><p>4, 使用build的镜像启动容器</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@opszn dockerfile]<span class="comment"># docker run -d -p 3306:3306 --name mariadb2 my_mariadb:v1</span></span><br></pre></td></tr></table></figure><h2 id="单个宿主机各容器互联方式"><a href="#单个宿主机各容器互联方式" class="headerlink" title="单个宿主机各容器互联方式"></a>单个宿主机各容器互联方式</h2><h3 id="通过link连接"><a href="#通过link连接" class="headerlink" title="通过link连接"></a>通过link连接</h3><p>使用该方式进行连接是单向的</p><p><strong>在docker宿主机上准备2个终端</strong></p><p><strong>终端一</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@opszn ~]<span class="comment"># docker run -it --name c1 centos:latest /bin/bash</span></span><br><span class="line">[root@<span class="number">551</span>b2985d420 /]<span class="comment"># yum install httpd -y </span></span><br><span class="line">[root@<span class="number">551</span>b2985d420 /]<span class="comment"># echo "c1 main page" &gt; /var/www/html/index.html</span></span><br><span class="line">[root@<span class="number">551</span>b2985d420 /]<span class="comment"># httpd -k start</span></span><br></pre></td></tr></table></figure><p><strong>终端二</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">使用--link c1:alias1来连接c1容器;alias1为c1容器的别名</span><br><span class="line">[root@opszn ~]<span class="comment"># docker run -it --link c1:alias1 --name c2 centos:latest /bin/bash</span></span><br><span class="line"></span><br><span class="line">这里容器c2上ping容器c1的别名是可以通的(但回到终端一 ping c2是能通的)</span><br><span class="line">[root@<span class="number">1</span>e8cd36da3af /]<span class="comment"># ping alias1</span></span><br><span class="line"></span><br><span class="line">通过elinks命令可以访问到容器c1的httpd主页</span><br><span class="line">[root@<span class="number">1</span>e8cd36da3af /]<span class="comment"># yum install elinks -y</span></span><br><span class="line">[root@<span class="number">1</span>e8cd36da3af /]<span class="comment"># elinks -dump http://alias1</span></span><br><span class="line">   c1 main page</span><br></pre></td></tr></table></figure><p><strong>小结:</strong> c2容器使用<code>--link c1:alias1</code>创建,其实就是在c2容器内的<code>/etc/hosts</code>文件里增加了c1的主机名别名绑定</p><h3 id="通过网络连接"><a href="#通过网络连接" class="headerlink" title="通过网络连接"></a>通过网络连接</h3><p>默认创建的容器都在同一个网络上,宿主机的docker0网卡也连接在此网络。</p><p><strong>这里我们需要用到三个终端</strong></p><p><strong>终端三</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">查看容器c1和c2的IP地址，发现这两个容器默认就在一个网络,所以直接用这两个IP就可以直接互相通迅了</span><br><span class="line">[root@opszn ~]<span class="comment"># docker inspect c1 |grep IPAddress |tail -1</span></span><br><span class="line">                    <span class="string">"IPAddress"</span>: <span class="string">"172.17.0.6"</span>,</span><br><span class="line">[root@opszn ~]<span class="comment"># docker inspect c2 |grep IPAddress |tail -1</span></span><br><span class="line">                    <span class="string">"IPAddress"</span>: <span class="string">"172.17.0.7"</span>,</span><br><span class="line">[root@opszn ~]<span class="comment"># ifconfig docker0 |head -2</span></span><br><span class="line">docker0: flags=<span class="number">4163</span>&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu <span class="number">1500</span></span><br><span class="line">        inet <span class="number">172.17</span>.<span class="number">0.1</span>  netmask <span class="number">255.255</span>.<span class="number">0.0</span>  broadcast <span class="number">0.0</span>.<span class="number">0.0</span></span><br></pre></td></tr></table></figure><p><strong>终端一</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">容器c1里ping容器c2的IP,可以通</span><br><span class="line">[root@<span class="number">551</span>b2985d420 /]<span class="comment"># ping -c 4 172.17.0.7</span></span><br><span class="line">PING <span class="number">172.17</span>.<span class="number">0.7</span> (<span class="number">172.17</span>.<span class="number">0.7</span>) <span class="number">56</span>(<span class="number">84</span>) bytes of data.</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">172.17</span>.<span class="number">0.7</span>: icmp_seq=<span class="number">1</span> ttl=<span class="number">64</span> time=<span class="number">0.237</span> ms</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">172.17</span>.<span class="number">0.7</span>: icmp_seq=<span class="number">2</span> ttl=<span class="number">64</span> time=<span class="number">0.394</span> ms</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">172.17</span>.<span class="number">0.7</span>: icmp_seq=<span class="number">3</span> ttl=<span class="number">64</span> time=<span class="number">0.118</span> ms</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">172.17</span>.<span class="number">0.7</span>: icmp_seq=<span class="number">4</span> ttl=<span class="number">64</span> time=<span class="number">0.081</span> ms</span><br></pre></td></tr></table></figure><p><strong>终端二</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">容器c2里ping容器c1的IP,可以通</span><br><span class="line">[root@<span class="number">1</span>e8cd36da3af /]<span class="comment"># ping -c 4 172.17.0.6</span></span><br><span class="line">PING <span class="number">172.17</span>.<span class="number">0.6</span> (<span class="number">172.17</span>.<span class="number">0.6</span>) <span class="number">56</span>(<span class="number">84</span>) bytes of data.</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">172.17</span>.<span class="number">0.6</span>: icmp_seq=<span class="number">1</span> ttl=<span class="number">64</span> time=<span class="number">0.340</span> ms</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">172.17</span>.<span class="number">0.6</span>: icmp_seq=<span class="number">2</span> ttl=<span class="number">64</span> time=<span class="number">0.077</span> ms</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">172.17</span>.<span class="number">0.6</span>: icmp_seq=<span class="number">3</span> ttl=<span class="number">64</span> time=<span class="number">0.054</span> ms</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">172.17</span>.<span class="number">0.6</span>: icmp_seq=<span class="number">4</span> ttl=<span class="number">64</span> time=<span class="number">0.100</span> ms</span><br></pre></td></tr></table></figure><h2 id="docker网络"><a href="#docker网络" class="headerlink" title="docker网络"></a>docker网络</h2><h3 id="本地网络"><a href="#本地网络" class="headerlink" title="本地网络"></a>本地网络</h3><p>默认docker本地网络有四种网络类型</p><table><thead><tr><th>bridge（默认网络类型）</th><th>不是vmware的桥接，倒是类似其NAT模式网络类型</th></tr></thead><tbody><tr><td>host</td><td>与宿主机共享网络，查看ip与宿主机相同，没有NAT转换，类似就跑在宿主机</td></tr><tr><td>none</td><td>只有lo本地回环网卡，无法连接网络</td></tr><tr><td>container</td><td>多个容器连接到此网络，容器间可以互相通信，不与宿主机共享网络。</td></tr></tbody></table><p>查看网络类型命令<strong>docker network ls</strong></p><h4 id="bridge网络"><a href="#bridge网络" class="headerlink" title="bridge网络"></a>bridge网络</h4><p>1.创建一个名为bridge0的bridge类型的网络,指定网段为10.3.3.0/24(<strong>此网段不能和宿主机已有的网段冲突</strong>),网关为10.3.3.1</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@opszn ~]<span class="comment"># docker network create -d bridge --subnet "10.3.3.0/24" --gateway "10.3.3.1" bridge0</span></span><br><span class="line"></span><br><span class="line">可以查看到bridge0这个网络,要删除的话使用docker network rm bridge0命令</span><br><span class="line">[root@opszn ~]<span class="comment"># docker network ls</span></span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line"><span class="number">6</span>f92ca98b6e7        bridge              bridge              local</span><br><span class="line"><span class="number">39</span>fe88f034d6        bridge0             bridge              local</span><br><span class="line"><span class="number">658477</span>d11b2c        host                host                local</span><br><span class="line"><span class="number">411</span>dc19aef37        none                null                local</span><br></pre></td></tr></table></figure><p>2.运行容器，指定使用刚创建的网络</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@opszn ~]<span class="comment"># docker run -it -d  --name c4 --network bridge0 centos:latest</span></span><br></pre></td></tr></table></figure><p>3.验证并测试此容器的网络</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@opszn ~]<span class="comment"># docker inspect c4 |grep IPAddress |tail -1</span></span><br><span class="line">                    <span class="string">"IPAddress"</span>: <span class="string">"10.3.3.2"</span>,</span><br><span class="line"></span><br><span class="line">可以ping通网关</span><br><span class="line">[root@opszn ~]<span class="comment"># docker exec c4 ping -c1 10.3.3.1</span></span><br><span class="line">PING <span class="number">10.3</span>.<span class="number">3.1</span> (<span class="number">10.3</span>.<span class="number">3.1</span>) <span class="number">56</span>(<span class="number">84</span>) bytes of data.</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">10.3</span>.<span class="number">3.1</span>: icmp_seq=<span class="number">1</span> ttl=<span class="number">64</span> time=<span class="number">0.319</span> ms</span><br><span class="line"></span><br><span class="line">可以上网</span><br><span class="line">[root@opszn ~]<span class="comment"># docker exec c4 ping -c1 www.baidu.cn</span></span><br><span class="line">PING www.a.shifen.com (<span class="number">14.215</span>.<span class="number">177.39</span>) <span class="number">56</span>(<span class="number">84</span>) bytes of data.</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">14.215</span>.<span class="number">177.39</span> (<span class="number">14.215</span>.<span class="number">177.39</span>): icmp_seq=<span class="number">1</span> ttl=<span class="number">55</span> time=<span class="number">7.51</span> ms</span><br></pre></td></tr></table></figure><p>4.宿主机上会产生一个网卡名为<strong>br-xxxxx</strong>, IP地址为设置的网关10.3.3.1</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@opszn ~]<span class="comment"># ifconfig |head -2</span></span><br><span class="line">br-<span class="number">39</span>fe88f034d6: flags=<span class="number">4163</span>&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu <span class="number">1500</span></span><br><span class="line">        inet <span class="number">10.3</span>.<span class="number">3.1</span>  netmask <span class="number">255.255</span>.<span class="number">255.0</span>  broadcast <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">如果想改名的话，可按下面步骤来做</span><br><span class="line">[root@opszn ~]<span class="comment"># ifconfig br-39fe88f034d6 down</span></span><br><span class="line">[root@opszn ~]<span class="comment"># ip link set dev br-39fe88f034d6 name docker1</span></span><br><span class="line">[root@opszn ~]<span class="comment"># ifconfig docker1 up</span></span><br><span class="line">[root@opszn ~]<span class="comment"># ifconfig docker1 |head -2</span></span><br><span class="line">docker1: flags=<span class="number">4163</span>&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu <span class="number">1500</span></span><br><span class="line">        inet <span class="number">10.3</span>.<span class="number">3.1</span>  netmask <span class="number">255.255</span>.<span class="number">255.0</span>  broadcast <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line">[root@opszn ~]<span class="comment"># systemctl restart docker</span></span><br></pre></td></tr></table></figure><h4 id="host模式"><a href="#host模式" class="headerlink" title="host模式"></a>host模式</h4><p>1.<strong>宿主机只能拥有一个host模式网络</strong>(和主机共享网络),再创建会报错</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@opszn ~]<span class="comment"># docker network create -d host host0</span></span><br><span class="line">Error response from daemon: only one instance of <span class="string">"host"</span> network is allowed</span><br></pre></td></tr></table></figure><p>2.运行容器, 指定使用host网络</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@opszn ~]<span class="comment"># docker run -it -d  --name c5 --network host centos:latest</span></span><br></pre></td></tr></table></figure><p>3.验证并测试此容器的网络</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">可以上公网</span><br><span class="line">[root@opszn ~]<span class="comment"># docker exec c5 ping -c1 www.baidu.com</span></span><br><span class="line">PING www.a.shifen.com (<span class="number">14.215</span>.<span class="number">177.39</span>) <span class="number">56</span>(<span class="number">84</span>) bytes of data.</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">14.215</span>.<span class="number">177.39</span> (<span class="number">14.215</span>.<span class="number">177.39</span>): icmp_seq=<span class="number">1</span> ttl=<span class="number">55</span> time=<span class="number">7.51</span> ms</span><br><span class="line"></span><br><span class="line">[root@opszn ~]<span class="comment"># docker exec c5 yum install net-tools -y</span></span><br><span class="line">容器里ifconfig得到的信息和宿主机上ifconfig得到的信息一致</span><br><span class="line">[root@opszn ~]<span class="comment"># docker exec c5 ifconfig</span></span><br></pre></td></tr></table></figure><h4 id="none"><a href="#none" class="headerlink" title="none"></a>none</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@opszn ~]<span class="comment"># docker run -itd --name c7 --network=none centos:latest /bin/bash</span></span><br></pre></td></tr></table></figure><h4 id="container"><a href="#container" class="headerlink" title="container"></a>container</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@opszn ~]<span class="comment"># docker run -itd --name c8 --network=container:c1 centos:latest /bin/bash</span></span><br></pre></td></tr></table></figure><p>说明: </p><ul><li>c8容器与c1容器的网络一致(包括IP)</li></ul><h3 id="跨本地网络"><a href="#跨本地网络" class="headerlink" title="跨本地网络"></a>跨本地网络</h3><p>在不同的宿主机上运行的容器通过映射端口，然后通过两台宿主机的ip与备映射的端口进行通讯，消耗的是宿主机的网络资源，某些场景并不适用。</p><p>能不能建立跨宿主机之间的网络,让容器使用自己的IP就可以通迅呢? 答案是肯定的，而且方案也有很多种: 有docker原生的overlay、macvlan和第三方方案flannel、weave、cacico 等.</p><p>这里我们重点介绍<strong>flannel</strong>参考:<a href="https://coreos.com/blog/introducing-rudder.html" target="_blank" rel="noopener">https://coreos.com/blog/introducing-rudder.html</a></p><h4 id="flannel网络"><a href="#flannel网络" class="headerlink" title="flannel网络"></a>flannel网络</h4><p>flannel是kubernetes默认提供网络插件,由CoreOS团队设计 </p><p>flannel实质上是一种“覆盖网络(overlay network)”, 也就是将TCP数据包装在另一种网络包里面进行路由转发和通信，目前已经支持UDP、VxLAN、AWS VPC和GCE路由等数据转发方式。</p><p>默认的节点间数据通信方式是UDP转发，在Flannel的GitHub页面有如下的一张原理图:</p><p><img src="/2019/03/22/docker容器2/flannel.png" alt></p><p>flannel可使用<strong>etcd</strong>存储,分配,维护子网信息,最终实现一个大网络内的不同子网可以互通。</p><h2 id="dockerweb管理平台"><a href="#dockerweb管理平台" class="headerlink" title="dockerweb管理平台"></a>dockerweb管理平台</h2><p>我想初学者都被docker的复杂命令搞得晕头转向了,希望有一个图形化的管理平台能轻松管理容器。类似的开源web管理平台主要有: DockerUI,Portainer,Shipyard等。Shipyard目前已经停止维护了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;docker容器2&quot;&gt;&lt;a href=&quot;#docker容器2&quot; class=&quot;headerlink&quot; title=&quot;docker容器2&quot;&gt;&lt;/a&gt;docker容器2&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="容器" scheme="https://www.opszn.com/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="docker" scheme="https://www.opszn.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker容器1</title>
    <link href="https://www.opszn.com/2019/03/20/docker%E5%AE%B9%E5%99%A81/"/>
    <id>https://www.opszn.com/2019/03/20/docker容器1/</id>
    <published>2019-03-20T01:02:51.000Z</published>
    <updated>2019-08-16T10:47:35.805Z</updated>
    
    <content type="html"><![CDATA[<h1 id="docker容器1"><a href="#docker容器1" class="headerlink" title="docker容器1"></a>docker容器1</h1><h2 id="PAAS"><a href="#PAAS" class="headerlink" title="PAAS"></a>PAAS</h2><p><strong>Platform As A Service(平台即服务)</strong></p><p><img src="/2019/03/20/docker容器1/%E4%BA%91%E8%AE%A1%E7%AE%97%E5%B1%82.jpg" alt></p><p>做云的优势: 提高资源利用率,将资源打包做成服务给用户使用,资源提供商极少需要与用户交互打交道。</p><p>CaaS (container as a service)容器即服务就是PAAS的一种实现</p><p>由于hypervisor虚拟化技术仍然存在一些性能和资源使用效率方面的问题，因此出现了一种称为容器技术（Container）的新型虚拟化技术来帮助解决这些问题。</p><p>容器: 是PAAS的一种实现,相对于虚拟机来说有更好的性能，更高的资源利用率。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>虚拟化技术可以在宿主机上安装多个不同的操作系统，运行多个不同的应用。但是回到我们之前文章中涉及到的机构层面来说，如果我只需要运行一台mysql或者nginx，却还需要另起一个操作系统，运行一些不必要的其他程序和内核。这对于服务器资源来说就显得非常的浪费，资源利用率很低。</p><p>所以有没有一种技术是可以只关注应用本身而放弃其她不必要的操作系统或者说内核呢？答案是肯定的，docker技术完美的为我们解决了这样的一个问题，docker中启用的应用，其操作系统与内核均与宿主机共享，极大程度的体现了资源的合理利用率。</p><ul><li>docker作为Linux中轻量级的虚拟化技术，其特点主要有：</li></ul><ol><li>轻量:只打包了需要的bins/libs(也就是命令和库文件)。与宿主机共享操作系统,直接使用宿主机的内核.</li><li>部署快: 容器的镜像相对虚拟机的镜像小。部署速度非常快，秒级部署</li><li>移植性好: Build once,Run anywhere(一次构建,随处部署运行)。  build,ship,run</li><li>资源利用率更高: 相对于虚拟机，不需要安装操作系统，所以几乎没有额外的CPU,内存消耗</li></ol><ul><li><p>相对于vmware等类似的虚拟机来说</p><p><img src="/2019/03/20/docker容器1/%E5%AE%B9%E5%99%A8%E4%B8%8E%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E6%AF%94%E5%9B%BE.png" alt></p></li></ul><h2 id="docker介绍"><a href="#docker介绍" class="headerlink" title="docker介绍"></a>docker介绍</h2><p><img src="/2019/03/20/docker容器1/docker%E5%9B%BE%E6%A0%87.png" alt></p><p>docker是目前来说最为火爆的容器技术软件，是go(golang语言开发的)</p><p>参考:<a href="https://www.docker.com/" target="_blank" rel="noopener">https://www.docker.com/</a></p><h3 id="docker版本"><a href="#docker版本" class="headerlink" title="docker版本"></a>docker版本</h3><p>自2017年3月后docker将其分为了CE版与EE版</p><table><thead><tr><th>docker-ce</th><th>社区版，安装简单快速，以便于快速开发</th></tr></thead><tbody><tr><td>docker-ee</td><td>企业版，提供更为安全的容器平台，以应用为中心。</td></tr></tbody></table><h3 id="docker内核技术"><a href="#docker内核技术" class="headerlink" title="docker内核技术"></a>docker内核技术</h3><table><thead><tr><th>docker进程</th><th>实质上就是宿主机进程</th></tr></thead><tbody><tr><td>name space</td><td>进行资源隔离</td></tr><tr><td>cgroups</td><td>进行资源限制</td></tr></tbody></table><h3 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h3><p>Linux内核实现namespace的一个主要目的就是实现轻量级虚拟化(容器)服务。在同一个namespace下的进程可以感知彼此的变化，而对外界的进程一无所知。</p><p>Linux 在很早的版本中就实现了部分的 namespace,比如内核 2.4 就实现了mount namespace。</p><p>大多数的namespace支持是在内核 2.6 中完成的，比如 IPC、Network、PID、和 UTS。还有个别的namespace 比较特殊，比如User，从内核 2.6 就开始实现了，但在内核 3.8 中才宣布完成。</p><p>同时，随着 Linux 自身的发展以及容器技术持续发展带来的需求，也会有新的 namespace 被支持，比如在内核 4.6 中就添加了Cgroup namespace。</p><p>inux内核提拱了6种namespace隔离的系统调用</p><table><thead><tr><th>namespace</th><th>系统调用参数</th><th>隔离内容</th></tr></thead><tbody><tr><td>UTS</td><td>CLONE_NEWUTS</td><td>主机名或域名</td></tr><tr><td>IPC</td><td>CLONE_NEWIPC</td><td>信号量、消息队列和共享内存</td></tr><tr><td>PID</td><td>CLONE_NEWPID</td><td>进程编号</td></tr><tr><td>net</td><td>CLONE_NEWNET</td><td>网络设备接口,IP路由表、防火墙规则等</td></tr><tr><td>mount</td><td>CLONE_NEWNS</td><td>挂载点(文件系统)</td></tr><tr><td>user</td><td>CLONE_NEWUSER</td><td>用户和用户组</td></tr></tbody></table><p>UTS:         每个NameSpace都拥有独立的主机名或域名，可以把每个NameSpace认为一个独立主机。</p><p>IPC:          每个容器依旧使用linux内核中进程交互的方法，实现进程间通信</p><p>PID:          每个容器都拥有独立的进程树，而容器是物理机中的一个进程，所以容器中的进程是物理机的线程</p><p>Net:         每个容器的网络是隔离</p><p>Mount:    每个容器的文件系统是独立的</p><p>User:       每个容器的用户和组ID是隔离，每个容器都拥有root用户</p><p>小结: 应用程序运行在一个隔离的空间(namespace)内, 每个隔离的空间都拥有独立的UTS,IPC,PID,Net,Mount,User.</p><p>cgroup（Control Group）</p><p>控制组（CGroups）是Linux内核的一个特性，<strong>主要用来对共享资源进行隔离、限制、审计等</strong>。</p><p>只有能控制分配到容器的资源，才能避免多个容器同时运行时对宿主机系统的资源竞争。</p><p>控制组可以提供对容器的内存、CPU、磁盘IO等资源进行限制和计费管理。</p><h3 id="lxc与docker区别"><a href="#lxc与docker区别" class="headerlink" title="lxc与docker区别"></a>lxc与docker区别</h3><p>Lxc为Linux Container的简写。可以提供轻量级的虚拟化.</p><p>docker的底层就是使用了LXC来实现的. docker以LXC为基础，实现了更多更强的功能。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>容器属于typeIII虚拟化,属于Paas</li><li>容器是一种轻量级，进程级的虚拟机</li><li>相比于虚拟机的优势<ul><li>不需要安装OS，和宿主机共享</li><li>镜像存储空间小</li><li>启动速度快(容器为秒级,虚拟机一般需要10秒左右)</li><li>移植性更好,更轻便</li><li>性能更好</li></ul></li><li>docker是一个实现容器的软件，底层使用LXC</li><li>docker主要使用namespace命名空间技术实现资源隔离,使用cgroup实现资源限制</li></ul><h2 id="镜像，容器，仓库"><a href="#镜像，容器，仓库" class="headerlink" title="镜像，容器，仓库"></a>镜像，容器，仓库</h2><table><thead><tr><th>镜像(image)</th><th>镜像就是打包好的环境与应用</th></tr></thead><tbody><tr><td>容器(contanier)</td><td>容器就是运行镜像的实例.    镜像看作是静态的,容器是动态的</td></tr><tr><td>仓库(repository)</td><td>存放多个镜像的一个仓库</td></tr></tbody></table><h2 id="镜像常见的操作"><a href="#镜像常见的操作" class="headerlink" title="镜像常见的操作"></a>镜像常见的操作</h2><table><thead><tr><th>docker images</th><th>查看当前镜像</th></tr></thead><tbody><tr><td>docker search docker_images</td><td>搜索某个镜像</td></tr><tr><td>docker pull docker_images</td><td>拉取某个镜像</td></tr><tr><td>docker push  docker_images</td><td>上传某个镜像</td></tr><tr><td>docker rmi docker_images</td><td>删除某个镜像</td></tr><tr><td>docker save  docker_images -o /path/dockername</td><td>导出某个镜像</td></tr><tr><td>docker load &lt;  /path/dockername</td><td>导入某个镜像</td></tr></tbody></table><h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><p>docker hub为最大的公开仓库,也就是官方仓库: <a href="https://hub.docker.com/我们进到官网注册一个用户" target="_blank" rel="noopener">https://hub.docker.com/我们进到官网注册一个用户</a>.</p><p>1.<strong>docker login</strong>(在宿主机登录用户)</p><p>在我们自己的宿主机上进行登录操作，方便我们在宿主机管理我们的官方仓库。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker login</span></span><br><span class="line">Login with your Docker ID to push and pull images from Docker Hub. <span class="keyword">If</span> you don<span class="string">'t have a Docker ID, head over to https://hub.docker.com to create one.</span></span><br><span class="line"><span class="string">Username: opszn</span></span><br><span class="line"><span class="string">Password: </span></span><br><span class="line"><span class="string">Login Succeeded</span></span><br></pre></td></tr></table></figure><p>2.*<em>docker tag *</em>（打标签）</p><p>我们在官方仓库下载的公开镜像是无法直接上传的需要重新对其“标识”（因为官方仓库已经存在该镜像的路径）</p><p>，所以我们这一步的操作相当于是给我们需要上传的镜像进行一个重新的命名以及路径的重定向）</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@opszn ~]<span class="comment"># docker push centos:latest</span></span><br><span class="line">Error response from daemon: You cannot push a <span class="string">"root"</span> repository. Please rename your repository to docker.io/&lt;user&gt;/&lt;repo&gt; (ex: docker.io/&lt;user&gt;/centos)</span><br><span class="line"></span><br><span class="line">[root@opszn ~]<span class="comment"># docker tag centos:latest linuxdaniel/daniel_docker_repo:V1</span></span><br><span class="line">[root@opszn ~]<span class="comment"># docker push linuxdaniel/daniel_docker_repo:V1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;docker容器1&quot;&gt;&lt;a href=&quot;#docker容器1&quot; class=&quot;headerlink&quot; title=&quot;docker容器1&quot;&gt;&lt;/a&gt;docker容器1&lt;/h1&gt;&lt;h2 id=&quot;PAAS&quot;&gt;&lt;a href=&quot;#PAAS&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="容器" scheme="https://www.opszn.com/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="docker" scheme="https://www.opszn.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>ansible配置自动化</title>
    <link href="https://www.opszn.com/2019/03/15/ansible%E9%85%8D%E7%BD%AE%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    <id>https://www.opszn.com/2019/03/15/ansible配置自动化/</id>
    <published>2019-03-15T06:50:22.000Z</published>
    <updated>2019-08-15T09:05:51.862Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ansible配置自动化"><a href="#ansible配置自动化" class="headerlink" title="ansible配置自动化"></a>ansible配置自动化</h1><h2 id="自动化运维是什么"><a href="#自动化运维是什么" class="headerlink" title="自动化运维是什么"></a>自动化运维是什么</h2><p>当我们需要多数量庞大的服务器进行统一管理的时候，按照传统的方法，我们可以通过ssh连接到服务器上进行操作。但是这个过程在数量很庞大的前提下就暴露出缺陷，比如说浪费了大量的时间重复做相同的操作，还有可能人工操作在重复这么频繁的情况下容易出现问题。那么这个时候，如果说能有一个工具或者软件，能够最大程度的减少重复的环节，这样就极大的提升了运维人员的工作效率。</p><p><strong>自动化运维</strong>: 将日常IT运维中大量的重复性工作，小到简单的日常检查、配置变更和软件安装，大到整个变更流程的组织调度，由过去的手工执行转为自动化操作，从而减少乃至消除运维中的延迟，实现“零延时”的IT运维。</p><h2 id="自动化运维主要关注的方面"><a href="#自动化运维主要关注的方面" class="headerlink" title="自动化运维主要关注的方面"></a>自动化运维主要关注的方面</h2><p>假如管理很多台服务器，主要关注以下几个方面:</p><ol><li><strong>管理机与被管理机的连接</strong>(管理机如何将管理指令发送给被管理机)</li><li><strong>服务器信息收集</strong>  (如果被管理的服务器有centos7.5外还有其它linux发行版,如suse,ubuntu等。当你要做的事情在不同OS上有所不同,你需要收集信息,并将其分开处理)</li><li><strong>服务器分组</strong>（因为有些时候我要做的事情不是针对所有服务器,可能只针对某一个分组） </li><li><strong>管理内容的主要分类</strong></li></ol><ul><li><strong>文件目录管理</strong>(包括文件的创建,删除,修改,查看状态,远程拷贝等)</li><li><strong>用户和组管理</strong></li><li><strong>cron时间任务管理</strong></li><li><strong>yum源配置与通过yum管理软件包</strong></li><li><strong>服务管理</strong></li><li><strong>远程执行脚本</strong></li><li><strong>远程执行命令</strong></li></ul><h2 id="常见的开源自动化运维工具比较"><a href="#常见的开源自动化运维工具比较" class="headerlink" title="常见的开源自动化运维工具比较"></a><strong>常见的开源自动化运维工具比较</strong></h2><ol><li><p>puppet</p><p>基于ruby语言，成熟稳定。适合于大型架构，相对于ansible和saltstack会复杂些。</p></li><li><p>saltstack</p><p>基于python语言。相对简单，大并发能力比ansible要好, 需要维护被管理端的服务。如果服务断开,连接就会出问题。</p></li><li><p>ansible</p><p>基于python语言。简单快捷，被管理端不需要启服务。直接走ssh协议,需要验证所以机器多的话速度会较慢。</p></li></ol><h2 id="ansible简介"><a href="#ansible简介" class="headerlink" title="ansible简介"></a>ansible简介</h2><p><img src="/2019/03/15/ansible配置自动化/ansible.png" alt></p><p>ansible是一种由Python开发的自动化运维工具，集合了众多运维工具（puppet、cfengine、chef、func、fabric）的优点，实现了批量系统配置、批量程序部署、批量运行命令等功能。</p><p>特点:</p><ul><li>部署简单</li><li><strong>默认使用ssh进行管理，基于python里的paramiko模块开发</strong></li><li>管理端和被管理端不需要启动服务</li><li>配置简单，功能强大，扩展性强</li><li>能过playbook(剧本)进行多个任务的编排</li></ul><h2 id="ansible分组"><a href="#ansible分组" class="headerlink" title="ansible分组"></a>ansible分组</h2><p>在分布式场景的架构中，我们经常需要对每一层集群进行单独的维护，这时候就需要用到分组。</p><p>ansible中通过一个主机清单功能来实现服务器分组。默认配置分组文件存在于(/etc/ansible/hosts)</p><p>例如：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[nginx]                        组名</span><br><span class="line">a[<span class="number">1</span>:<span class="number">10</span>].web.com                表示a1.web.com到a10.web.com这<span class="number">10</span>台服务器</span><br><span class="line">b[a:z].web.com               表示ba.web.com到bz.web.com这<span class="number">26</span>台服务器</span><br><span class="line"><span class="number">10.1</span>.<span class="number">1</span>.[<span class="number">10</span>:<span class="number">15</span>]               表示<span class="number">10.1</span>.<span class="number">1.10</span>到<span class="number">10.1</span>.<span class="number">1.15</span>这<span class="number">5</span>台服务器</span><br><span class="line"></span><br><span class="line"><span class="comment">##表示这台主机，但是ssh端口为11111</span></span><br><span class="line"><span class="number">1.1</span>.<span class="number">1.10</span>:<span class="number">11111</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##定义10.1.1.12:2222这台服务器的别名为nginx1</span></span><br><span class="line">nginx1 ansible_ssh_host=<span class="number">10.1</span>.<span class="number">1.13</span> ansible_ssh_port=<span class="number">2222</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##没有做免密登录的服务器可以指定用户名与密码</span></span><br><span class="line">nginx1  ansible_ssh_host=<span class="number">10.1</span>.<span class="number">1.13</span> ansible_ssh_port=<span class="number">2222</span> ansible_ssh_user=root ansible_ssh_pass=<span class="string">"123456"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##利用别名来分组</span></span><br><span class="line">nginx1  ansible_ssh_host=<span class="number">10.1</span>.<span class="number">1.13</span> ansible_ssh_port=<span class="number">2222</span> ansible_ssh_user=root ansible_ssh_pass=<span class="string">"123456"</span></span><br><span class="line">nginx2  ansible_ssh_host=<span class="number">10.1</span>.<span class="number">1.12</span></span><br><span class="line">[nginx]</span><br><span class="line">nginx1</span><br><span class="line">nginx2</span><br></pre></td></tr></table></figure><p><strong>小结:</strong></p><p>主机清单的作用: 服务器分组。</p><p>主机清单的常见功能:</p><ol><li>可以通过IP范围来分, 主机名名字的范围来分</li><li>如果ssh端口不是22的，可以传入新的端口。</li><li>没有做免密登录，可以传密码。</li></ol><h2 id="ansible模块"><a href="#ansible模块" class="headerlink" title="ansible模块"></a>ansible模块</h2><p>ansible是基于模块工作的，本身没有批量部署的能力。真正具有批量部署的是ansible所运行的模块，ansible只是提供一种框架。</p><p>ansible支持的模块非常的多，我们并不需要把每个模块都记住，而只需要熟悉一些常见的模块，其它的模块在需要用到时再查询即可。</p><table><thead><tr><th>模块名</th><th>用途</th></tr></thead><tbody><tr><td>hostname</td><td>修改主机名</td></tr><tr><td>file</td><td>文件的创建，删除，软连接等</td></tr><tr><td>stat</td><td>文件的状态信息</td></tr><tr><td>copy</td><td>本地文件拷贝到远程</td></tr><tr><td>fetch</td><td>远程文件拷贝到本地</td></tr><tr><td>user</td><td>管理用户账号和用户属性</td></tr><tr><td>group</td><td>管理用户组和用户组属性</td></tr><tr><td>cron</td><td>计划任务</td></tr><tr><td>yum_repository</td><td>配置yum仓库</td></tr><tr><td>yum</td><td>软件包安装与卸载</td></tr><tr><td>service</td><td>服务的管理，开机自启动等</td></tr><tr><td>script</td><td>执行本地脚本</td></tr><tr><td>command与shell</td><td>执行Linux命令</td></tr><tr><td>setup</td><td>收集远程主机的基本信息</td></tr></tbody></table><h2 id="playbook"><a href="#playbook" class="headerlink" title="playbook"></a>playbook</h2><p>playbook(剧本): 是ansible用于配置,部署,和管理被控节点的剧本。用于ansible操作的编排。</p><p>参考:<a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_intro.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_intro.html</a></p><p>使用的格式为<strong>yaml</strong>格式（saltstack,elk,docker等也都会用到yaml格式) </p><h3 id="YMAL格式"><a href="#YMAL格式" class="headerlink" title="YMAL格式"></a>YMAL格式</h3><ul><li>文件的第一行以 “—“开始，表明YMAL文件的开始.</li><li>以#号开头为注释</li><li>列表中的所有成员都开始于相同的缩进级别, 并且使用一个 <code>&quot;- &quot;</code> 作为开头(一个横杠和一个空格)</li><li>一个字典是由一个简单的 <code>键: 值</code> 的形式组成(这个冒号后面必须是一个空格)</li><li><strong>注意: 写这种文件不要使用tab键，都使用空格</strong></li></ul><p>参考: <a href="https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html#yaml-syntax" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html#yaml-syntax</a></p><p>下面看一个官方的示例</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="comment"># 一位职工记录</span></span><br><span class="line">name: Example Developer</span><br><span class="line">job: Developer</span><br><span class="line">skill: Elite</span><br><span class="line">employed: True</span><br><span class="line">foods:</span><br><span class="line">    - Apple</span><br><span class="line">    - Orange</span><br><span class="line">    - Strawberry</span><br><span class="line">    - Mango</span><br><span class="line">languages:</span><br><span class="line">    ruby: Elite</span><br><span class="line">    python: Elite</span><br><span class="line">    dotnet: Lame</span><br></pre></td></tr></table></figure><h3 id="playbook常见语法"><a href="#playbook常见语法" class="headerlink" title="playbook常见语法"></a>playbook常见语法</h3><table><thead><tr><th>语法</th><th>释义</th></tr></thead><tbody><tr><td>hosts</td><td>指定要执行任务的主机，其可以是一个或多个由冒号分隔主机组</td></tr><tr><td>remote_user</td><td>指定远程主机上的执行任务的用户.</td></tr><tr><td>tasks</td><td>任务列表，按照顺序执行</td></tr><tr><td>handlers</td><td>类似task，但需要使用notify通知调用（只执行一次，最实用服务火或计算机触发重启）</td></tr><tr><td>variables</td><td>变量，定义变量可以被多次调用</td></tr><tr><td>with_items</td><td>迭代列表（如安装软件包）</td></tr></tbody></table><p>比较抽象不好理解，我们来编写一个实例加深理解</p><p>实例：实现配置yum，安装vsftpd软件包，修改配置文件拒绝远程用户登录，启动服务并设置为开机自启动</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">- hosts: group1   定义组名为group1            </span><br><span class="line">  remote_user: root  定义上述组中各服务器执行任务的用户为root                   </span><br><span class="line">  tasks:   定义任务列表                             </span><br><span class="line">  - name: rm yum repository   定义任务<span class="number">1</span>名称      </span><br><span class="line">    file: path=/etc/yum.repos.d/ state=absent  </span><br><span class="line">    </span><br><span class="line">  - name: 同步master上的yum源到group1</span><br><span class="line">    copy: src=/etc/yum.repos.d dest=/etc/</span><br><span class="line">    </span><br><span class="line">  - name: ensure vsftpd is at the latest version        </span><br><span class="line">    yum: name=vsftpd state=latest</span><br><span class="line">    </span><br><span class="line">  - name: write the apache config file          </span><br><span class="line">    copy: src=/etc/vsftpd/vsftpd.conf dest=/etc/vsftpd/vsftpd.conf </span><br><span class="line">    </span><br><span class="line">    notify:                             </span><br><span class="line">    - restart vsftpd</span><br><span class="line">    </span><br><span class="line">  - name: ensure vsftpd is running (and enable it at boot)</span><br><span class="line">    service: name=vsftpd state=started enabled=yes</span><br><span class="line">    </span><br><span class="line">  handlers:                     </span><br><span class="line">    - name: restart vsftpd              </span><br><span class="line">      service: name=vsftpd state=restarted</span><br></pre></td></tr></table></figure><h2 id="roles"><a href="#roles" class="headerlink" title="roles"></a>roles</h2><p>roles(角色): 就是通过分别将variables, tasks及handlers等放置于单独的目录中,并可以便捷地调用它们的一种机制。</p><p>假设我们要写一个playbook来安装管理lamp环境，那么这个playbook就会写很长。所以我们希望把这个很大的文件分成多个功能拆分, 分成apache管理,php管理,mysql管理，然后在需要使用的时候直接调用就可以了，以免重复写。就类似编程里的模块化的概念，以达到代码复用的效果。</p><h3 id="创建roles的目录结构"><a href="#创建roles的目录结构" class="headerlink" title="创建roles的目录结构"></a>创建roles的目录结构</h3><table><thead><tr><th>files</th><th>用来存放由copy模块或script模块调用的文件</th></tr></thead><tbody><tr><td>tasks</td><td>至少有一个main.yml文件，定义各tasks</td></tr><tr><td>handlers</td><td>有一个main.yml文件，定义各handlers</td></tr><tr><td>templates</td><td>用来存放jinjia2模板</td></tr><tr><td>vars</td><td>有一个main.yml文件，定义变量</td></tr><tr><td>meta</td><td>有一个main.yml文件，定义此角色的特殊设定及其依赖关系</td></tr></tbody></table><p>上述目录都需创建，即便是空目录也要安排的明明白白。</p><h3 id="通过roles实现lamp"><a href="#通过roles实现lamp" class="headerlink" title="通过roles实现lamp"></a>通过roles实现lamp</h3><p>那么我们可以知道为了实现lamp的话，需要设置3个role分别为httpd，php,mysql</p><ul><li><p>创建roles目录以及文件,并确认目录结构</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">master<span class="comment"># tree /etc/ansible/roles/</span></span><br><span class="line">/etc/ansible/roles/</span><br><span class="line">├── httpd</span><br><span class="line">│   ├── files</span><br><span class="line">│   ├── handlers</span><br><span class="line">│   │   └── main.yml</span><br><span class="line">│   ├── meta</span><br><span class="line">│   │   └── main.yml</span><br><span class="line">│   ├── tasks</span><br><span class="line">│   │   └── main.yml</span><br><span class="line">│   ├── templates</span><br><span class="line">│   └── vars</span><br><span class="line">│       └── main.yml</span><br><span class="line">├── mysql</span><br><span class="line">│   ├── files</span><br><span class="line">│   ├── handlers</span><br><span class="line">│   │   └── main.yml</span><br><span class="line">│   ├── meta</span><br><span class="line">│   │   └── main.yml</span><br><span class="line">│   ├── tasks</span><br><span class="line">│   │   └── main.yml</span><br><span class="line">│   ├── templates</span><br><span class="line">│   └── vars</span><br><span class="line">│       └── main.yml</span><br><span class="line">└── php</span><br><span class="line">    ├── files</span><br><span class="line">    ├── handlers</span><br><span class="line">    │   └── main.yml</span><br><span class="line">    ├── meta</span><br><span class="line">    │   └── main.yml</span><br><span class="line">    ├── tasks</span><br><span class="line">    │   └── main.yml</span><br><span class="line">    ├── templates</span><br><span class="line">    └── vars</span><br><span class="line">        └── main.yml</span><br></pre></td></tr></table></figure></li><li><p>准备httpd服务器主页文件，php测试页面以及配置文件等</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">master<span class="comment"># echo "test main page" &gt; /etc/ansible/roles/httpd/files/index.html</span></span><br><span class="line">master<span class="comment"># echo -e "&lt;?php/n/tphpinfo();/n?&gt;" &gt; /etc/ansible/roles/httpd/files/test.php </span></span><br><span class="line"></span><br><span class="line">master<span class="comment"># yum install httpd -y</span></span><br><span class="line"></span><br><span class="line">按需求修改配置文件后,拷贝到httpd角色目录里的files子目录</span><br><span class="line">master<span class="comment"># vim /etc/httpd/conf/httpd.conf</span></span><br><span class="line">master<span class="comment"># cp /etc/httpd/conf/httpd.conf /etc/ansible/roles/httpd/files/</span></span><br></pre></td></tr></table></figure></li><li><p>编写httpd角色的main.yml文件</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">master<span class="comment"># vim /etc/ansible/roles/httpd/tasks/main.yml</span></span><br><span class="line">---</span><br><span class="line">- name: install httpd</span><br><span class="line">  yum: name=&#123;&#123;item&#125;&#125; state=latest</span><br><span class="line">  with_items:</span><br><span class="line">    - httpd</span><br><span class="line">    - httpd-devel</span><br><span class="line"></span><br><span class="line">- name: copy index file</span><br><span class="line">  copy: src=/etc/ansible/roles/httpd/files/index.html dest=/var/www/html/index.html</span><br><span class="line"></span><br><span class="line">- name: copy test_php file</span><br><span class="line">  copy: src=/etc/ansible/roles/httpd/files/test.php dest=/var/www/html/test.php</span><br><span class="line"></span><br><span class="line">- name: copy conf file</span><br><span class="line">  copy: src=/etc/ansible/roles/httpd/files/httpd.conf dest=/etc/httpd/conf/httpd.conf</span><br><span class="line">  </span><br><span class="line">  notify:</span><br><span class="line">  - restart httpd</span><br><span class="line"></span><br><span class="line">- name: start httpd</span><br><span class="line">  service: name=httpd enabled=true state=started</span><br></pre></td></tr></table></figure></li><li><p>httpd角色的handlers</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">master<span class="comment"># vim /etc/ansible/roles/httpd/handlers/main.yml</span></span><br><span class="line">---</span><br><span class="line">- name: restart httpd  </span><br><span class="line">  service: name=httpd state=restarted</span><br></pre></td></tr></table></figure></li><li><p>mysql角色的main.yml文件</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">master<span class="comment"># vim /etc/ansible/roles/mysql/tasks/main.yml</span></span><br><span class="line">---</span><br><span class="line">- name: install mariadb </span><br><span class="line">  yum: name=&#123;&#123;item&#125;&#125; state=latest</span><br><span class="line">  with_items:</span><br><span class="line">    - mariadb</span><br><span class="line">    - mariadb-server</span><br><span class="line">    - mariadb-libs</span><br><span class="line">    - mariadb-devel</span><br><span class="line">    </span><br><span class="line">- name: start service</span><br><span class="line">  service: name=mariadb enabled=true state=started</span><br></pre></td></tr></table></figure></li><li><p>php角色的main.yml文件</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">master<span class="comment"># vim /etc/ansible/roles/php/tasks/main.yml</span></span><br><span class="line">---</span><br><span class="line">- name: install php</span><br><span class="line">  yum: name=&#123;&#123;item&#125;&#125; state=latest</span><br><span class="line">  with_items:</span><br><span class="line">    - php</span><br><span class="line">    - php-mysql</span><br><span class="line">    - php-gd</span><br><span class="line">    - php-ldap</span><br><span class="line">    - php-odbc</span><br><span class="line">    - php-pear</span><br><span class="line">    - php-xml</span><br><span class="line">    - php-xmlrpc</span><br><span class="line">    - php-mbstring</span><br><span class="line">    - php-snmp</span><br><span class="line">    - php-soap</span><br><span class="line">    - curl</span><br><span class="line">    - curl-devel </span><br><span class="line">    - php-bcmath</span><br></pre></td></tr></table></figure></li><li><p>playbook编写</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">master<span class="comment"># vim /etc/ansible/playbook/lamp.yaml</span></span><br><span class="line">---</span><br><span class="line">- hosts: group1</span><br><span class="line">  remote_user: root</span><br><span class="line">  roles:</span><br><span class="line">    - httpd</span><br><span class="line">    - mysql</span><br><span class="line">    - php</span><br></pre></td></tr></table></figure></li><li><p>执行</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">master<span class="comment"># ansible-playbook /etc/ansible/playbook/lamp.yaml</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ansible配置自动化&quot;&gt;&lt;a href=&quot;#ansible配置自动化&quot; class=&quot;headerlink&quot; title=&quot;ansible配置自动化&quot;&gt;&lt;/a&gt;ansible配置自动化&lt;/h1&gt;&lt;h2 id=&quot;自动化运维是什么&quot;&gt;&lt;a href=&quot;#自动化运维
      
    
    </summary>
    
      <category term="自动化" scheme="https://www.opszn.com/categories/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    
      <category term="ansible" scheme="https://www.opszn.com/tags/ansible/"/>
    
  </entry>
  
  <entry>
    <title>Git+Gitlab+Jenkins_3</title>
    <link href="https://www.opszn.com/2019/02/23/Git-Gitlab-Jenkins-3/"/>
    <id>https://www.opszn.com/2019/02/23/Git-Gitlab-Jenkins-3/</id>
    <published>2019-02-23T01:55:03.000Z</published>
    <updated>2019-08-14T09:23:15.001Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git-Gitlab-Jenkins-3-Jenkins"><a href="#Git-Gitlab-Jenkins-3-Jenkins" class="headerlink" title="Git+Gitlab+Jenkins_3(Jenkins)"></a>Git+Gitlab+Jenkins_3(Jenkins)</h1><h2 id="jenkins简介"><a href="#jenkins简介" class="headerlink" title="jenkins简介"></a>jenkins简介</h2><p>Jenkins是一个可扩展的持续集成引擎，是一个开源软件项目，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。Jenkins非常易于安装和配置，简单易用。</p><p>官网：<a href="https://jenkins.io/" target="_blank" rel="noopener">https://jenkins.io/</a></p><h2 id="jenkins应用场景"><a href="#jenkins应用场景" class="headerlink" title="jenkins应用场景"></a>jenkins应用场景</h2><p><strong>场景1</strong></p><p><img src="/2019/02/23/Git-Gitlab-Jenkins-3/1.png" alt></p><ul><li>研发人员上传开发好的代码到gitlab代码仓库</li><li>需要将代码下载到nginx服务器部署<ul><li>运维人员手动下载再部署</li><li>运维人员使用脚本下载再部署</li></ul></li></ul><p><strong>场景2</strong></p><p><img src="/2019/02/23/Git-Gitlab-Jenkins-3/2.png" alt></p><h2 id="jenkins安装"><a href="#jenkins安装" class="headerlink" title="jenkins安装"></a>jenkins安装</h2><p>1.下载及环境配置</p><p>可由面提到的官网进行下载，还需要部署openjdk环境</p><p>2.界面安装</p><p><img src="/2019/02/23/Git-Gitlab-Jenkins-3/jenkins%E7%95%8C%E9%9D%A21.png" alt></p><p><img src="/2019/02/23/Git-Gitlab-Jenkins-3/jenkins%E7%95%8C%E9%9D%A22.png" alt></p><p><img src="/2019/02/23/Git-Gitlab-Jenkins-3/jenkins%E7%95%8C%E9%9D%A23.png" alt></p><p><img src="/2019/02/23/Git-Gitlab-Jenkins-3/jenkins%E7%95%8C%E9%9D%A24.png" alt></p><p><img src="/2019/02/23/Git-Gitlab-Jenkins-3/jenkins%E7%95%8C%E9%9D%A25.png" alt></p><p><img src="/2019/02/23/Git-Gitlab-Jenkins-3/jenkins%E7%95%8C%E9%9D%A26.png" alt></p><p><img src="/2019/02/23/Git-Gitlab-Jenkins-3/jenkins%E7%95%8C%E9%9D%A27.png" alt></p><h2 id="退出登录的密码问题"><a href="#退出登录的密码问题" class="headerlink" title="退出登录的密码问题"></a>退出登录的密码问题</h2><p>1.log out登出后,再次登录使用admin用户, 密码为<code>cat /var/lib/jenkins/secrets/initialAdminPassword</code>得到字符串</p><p>2.如果要修改密码,按下面图示操作</p><p><img src="/2019/02/23/Git-Gitlab-Jenkins-3/jenkins%E7%9A%84admin%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E4%BF%AE%E6%94%B91.png" alt></p><p><img src="/2019/02/23/Git-Gitlab-Jenkins-3/jenkins%E7%9A%84admin%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E4%BF%AE%E6%94%B92.png" alt></p><p>3.如果忘记密码, 按下面方法可以免出验证进行登录</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cp  /var/lib/jenkins/config.xml /备份目录/config.xml.bak</span></span><br><span class="line">先备份一下</span><br><span class="line"></span><br><span class="line"><span class="comment"># vim /var/lib/jenkins/config.xml</span></span><br><span class="line">打开此文件,然后把下面的一段注释(使用&lt;!--  --&gt;来注释)或删除</span><br><span class="line"></span><br><span class="line">     &lt;useSecurity&gt;true&lt;/useSecurity&gt;</span><br><span class="line">     &lt;authorizationStrategy class=<span class="string">"hudson.security.FullControlOnceLoggedInAuthorizationStrategy"</span>&gt;</span><br><span class="line">      &lt;denyAnonymousReadAccess&gt;true&lt;/denyAnonymousReadAccess&gt;</span><br><span class="line">    &lt;/authorizationStrategy&gt;</span><br><span class="line">    &lt;securityRealm class=<span class="string">"hudson.security.HudsonPrivateSecurityRealm"</span>&gt;</span><br><span class="line">      &lt;disableSignup&gt;true&lt;/disableSignup&gt;</span><br><span class="line">      &lt;enableCaptcha&gt;false&lt;/enableCaptcha&gt;</span><br><span class="line">    &lt;/securityRealm&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># systemctl stop jenkins</span></span><br><span class="line"><span class="comment"># systemctl start jenkins</span></span><br><span class="line">重启服务后,web访问就不需要密码验证了</span><br></pre></td></tr></table></figure><h2 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h2><p>1.因为下载插件的官方在国外,网络可能会不稳定。如果在安装插件那一步出现offline或者找不到XXX插件的报错,可以换个网络试试。或者休息一下,换个时间再试。还不行可以试试下面的方法</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /var/lib/jenkins/hudson.model.UpdateCenter.xml</span></span><br><span class="line"></span><br><span class="line">&lt;?xml version=<span class="string">'1.1'</span> encoding=<span class="string">'UTF-8'</span>?&gt;</span><br><span class="line">&lt;sites&gt;</span><br><span class="line">  &lt;site&gt;</span><br><span class="line">    &lt;id&gt;default&lt;/id&gt;</span><br><span class="line">    &lt;url&gt;https://updates.jenkins.io/update-center.json&lt;/url&gt;</span><br><span class="line">  &lt;/site&gt;</span><br><span class="line">&lt;/sites&gt;</span><br><span class="line"></span><br><span class="line">把上面的https改为http的访问</span><br><span class="line">保存后重启jenkins服务再尝试</span><br></pre></td></tr></table></figure><p>2, 如果实在是无法下载插件,可将下载好的插件打包给你，解压到/var/lib/jenkins/plugins/目录。需要重启jenkins服务,才能在web界面读取到解压的插件。</p><h2 id="自动发布系统"><a href="#自动发布系统" class="headerlink" title="自动发布系统"></a>自动发布系统</h2><p>Jenkins安装gitlab与gitlab hook插件</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Git-Gitlab-Jenkins-3-Jenkins&quot;&gt;&lt;a href=&quot;#Git-Gitlab-Jenkins-3-Jenkins&quot; class=&quot;headerlink&quot; title=&quot;Git+Gitlab+Jenkins_3(Jenkins)&quot;&gt;&lt;/a&gt;G
      
    
    </summary>
    
      <category term="Jenkins" scheme="https://www.opszn.com/categories/Jenkins/"/>
    
    
      <category term="CI/CD" scheme="https://www.opszn.com/tags/CI-CD/"/>
    
  </entry>
  
  <entry>
    <title>Git+Gitlab+Jenkins_2</title>
    <link href="https://www.opszn.com/2019/02/22/Git-Gitlab-Jenkins-2/"/>
    <id>https://www.opszn.com/2019/02/22/Git-Gitlab-Jenkins-2/</id>
    <published>2019-02-22T08:06:06.000Z</published>
    <updated>2019-08-14T08:54:52.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git-Gitlab-Jenkins-2-Gitlab"><a href="#Git-Gitlab-Jenkins-2-Gitlab" class="headerlink" title="Git+Gitlab+Jenkins_2(Gitlab)"></a>Git+Gitlab+Jenkins_2(Gitlab)</h1><h2 id="Gitlab与GitHub"><a href="#Gitlab与GitHub" class="headerlink" title="Gitlab与GitHub"></a>Gitlab与GitHub</h2><p>两者之间功能类似，前者主要用于内网环境，后者在公网环境。</p><p>一般公司业务考虑到其代码安全问题，会部署内网环境的Gitlab。</p><h2 id="gitlab下载"><a href="#gitlab下载" class="headerlink" title="gitlab下载"></a>gitlab下载</h2><p><a href="https://mirrors.tuna.tsinghua.edu.cn推荐使用清华源进行下载，本次环境选用的是社区版。" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn推荐使用清华源进行下载，本次环境选用的是社区版。</a></p><p><strong>安装以及配置</strong></p><p>由于我们自己去公网环境下载的软件包，安装就简单的用yum安装即可（rpm也可以，但是yum安装rpm包时会自动安装其依赖，当然这个环境没有依赖，个人习惯）。</p><p>接下来修改配置</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@gitlab ~]<span class="comment"># vim /etc/gitlab/gitlab.rb</span></span><br><span class="line">external_url <span class="string">'http://1.1.1.10'</span>  将ip改为gitlab服务器的ip，方便内网进行访问</span><br></pre></td></tr></table></figure><p><strong>初始化</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@gitlab ~]<span class="comment"># gitlab-ctl reconfigure</span></span><br><span class="line">[root@gitlab ~]<span class="comment"># gitlab-ctl status</span></span><br></pre></td></tr></table></figure><h2 id="gitlab登录"><a href="#gitlab登录" class="headerlink" title="gitlab登录"></a>gitlab登录</h2><p>我们哦通过浏览器访问gitlab服务器ip，首次登录我们需要设置密码。</p><p>设置邮箱的用途：<br>1.账号注册时，邮件验证</p><p>2.有合并请求时，邮件通知</p><p>3.修改密码时，通过邮件修改</p><h2 id="开发者设置ssh密钥粘贴至gitlab"><a href="#开发者设置ssh密钥粘贴至gitlab" class="headerlink" title="开发者设置ssh密钥粘贴至gitlab"></a>开发者设置ssh密钥粘贴至gitlab</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">产生密钥对</span><br><span class="line">ssh-keygen</span><br><span class="line">查看公钥</span><br><span class="line">cat /root/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>之后回到浏览器进入设置，将公钥粘贴至gitlab中</p><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p>gitlab创建仓库同github，图形化的创建，这里略过。</p><h2 id="克隆远程仓库到本地"><a href="#克隆远程仓库到本地" class="headerlink" title="克隆远程仓库到本地"></a>克隆远程仓库到本地</h2><h3 id="在开发者电脑上配置身份标识"><a href="#在开发者电脑上配置身份标识" class="headerlink" title="在开发者电脑上配置身份标识"></a>在开发者电脑上配置身份标识</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@opszn ~]<span class="comment"># git config --global user.name "opszn"</span></span><br><span class="line">[root@opszn ~]<span class="comment"># git config --global user.email "mail@opszn.com"</span></span><br><span class="line">[root@opszn ~]<span class="comment"># git clone git@1.1.1.10:root/mywebsite.git</span></span><br></pre></td></tr></table></figure><h3 id="在开发者电脑上进行克隆并上传"><a href="#在开发者电脑上进行克隆并上传" class="headerlink" title="在开发者电脑上进行克隆并上传"></a>在开发者电脑上进行克隆并上传</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@opszn ~]<span class="comment"># cd mywebsite/</span></span><br><span class="line"></span><br><span class="line">[root@opszn mywebsite]<span class="comment"># echo "test web" &gt; README.md</span></span><br><span class="line">[root@opszn mywebsite]<span class="comment"># git add .</span></span><br><span class="line">[root@opszn mywebsite]<span class="comment"># git commit -m "add README.md"</span></span><br><span class="line"></span><br><span class="line">[root@opszn mywebsite]<span class="comment"># git push -u origin master</span></span><br></pre></td></tr></table></figure><p>上传完成后我们就可以在浏览器端看到仓库中有了新的文件</p><p><strong>小结</strong></p><p>git  分布式版本控制工具</p><p>github和gitlab都属于远程仓库</p><p>git clone: 把远程仓库的项目代码下载到本地</p><p>git push: 把本地的项目代码上传到远程仓库</p><p>git pull:  把远程仓库的项目代码更新到本地</p><p>远程仓库两种访问方法:</p><ul><li>http  </li><li>ssh  使用空密码密钥做免密</li></ul><h2 id="持续集成（CI）"><a href="#持续集成（CI）" class="headerlink" title="持续集成（CI）"></a>持续集成（CI）</h2><p><strong>Continuous integration简称CI</strong></p><p> 是一种软件开发实践，即团队开发成员经常集成他们的工作，通常每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试)来验证，从而尽快地发现集成错误。</p><p><img src="/2019/02/22/Git-Gitlab-Jenkins-2/1.png" alt></p><p><strong>目的</strong></p><p>​        持续集成的目的不是减少build失败的次数，而是<strong>尽早发现问题，在最短的时间内解决问题</strong>，减少风险和浪费。从而让产品开发流程更加敏捷，缩短产品开发周期，在产品上线后，让用户用得更加顺畅。</p><p>​        在没有应用持续集成之前，传统的开发模式是项目一开始就划分模块，每个开发人员分别负责一个模块，等所有的代码都开发完成之后再集成到一起提交给测试人员，随着软件技术团队的发展，软件已经不能简单地通过划分模块的方式来开发，需要项目内部相互协作，划分模块这种传统的模式的弊端也越来越明显。由于很多bug在项目早期的设计、编码阶段就引入，到最后集成测试时才发现问题，开发人员需要花费大量的时间来定位bug，加上软件的复杂性，bug的定位就更难了，甚至出现不得不调整底层架构的情况。这种情况的发生不仅仅对测试进度造成影响，而且会拖长整个项目周期。</p><p>​       而持续集成可以有效解决软件开发过程中的许多问题，在集成测试阶段之前就帮助开发人员发现问题，从而可以有效的确保软件质量，减小项目的风险，使软件开发团队从容的面对各种变化。持续集成报告中可以体现目前项目进度，哪部分需要已经实现，哪些代码已经通过自动化测试，代码质量如何，让开发团队和项目组了解项目的真实状况。</p><h2 id="持续交付（CD）"><a href="#持续交付（CD）" class="headerlink" title="持续交付（CD）"></a>持续交付（CD）</h2><p><strong>Continuous Delivery，简称CD</strong></p><p> 持续交付是指软件开发过程，从原始需求到最终产品开发过程中，较短周期内以需求的小颗粒度（小批量）频繁提交的过程。主要指集成后的代码在类生产环境(测试环境,预发布环境等)中测试并及时反馈的过程。</p><p><img src="/2019/02/22/Git-Gitlab-Jenkins-2/2.png" alt></p><p><strong>目的</strong></p><ol><li>开发过程的快速迭代，小步快跑，及时纠正偏离主线</li><li>小颗粒度实现，避免颗粒度大，出现问题解决麻烦</li><li>迅速反馈软件功能，避免方向性错误</li><li>团队角色（含客户）协作密切，减少时间浪费</li></ol><h2 id="持续部署（CD）"><a href="#持续部署（CD）" class="headerlink" title="持续部署（CD）"></a>持续部署（CD）</h2><p><strong>Continuous Deployment，简称CD</strong></p><p>基于持续交付的基础上，把功能稳定，符合产品需求的版本有方法地部署至生产环境中。可以看作是持续交付的最后一环。</p><p><img src="/2019/02/22/Git-Gitlab-Jenkins-2/3.png" alt></p><h3 id="蓝绿部署"><a href="#蓝绿部署" class="headerlink" title="蓝绿部署"></a>蓝绿部署</h3><p>海豚分左脑右脑，活跃的时候都清醒；休息的时候一边清醒一边休眠，每两个小时切换一次。</p><p>蓝绿部署也可将集群分为两个部分，没有版本修改时两边整个集群都处于活跃状态。当我们需要进行版本修改时，先停掉一半的业务进行版本修改，修改完成后进行上线，之后再停掉另外一半的业务进行修改。这样就实现了不停机更新。</p><h3 id="滚动更新"><a href="#滚动更新" class="headerlink" title="滚动更新"></a>滚动更新</h3><p>滚动更新，英文Rolling update，同样是一种可以保证系统在不间断提供服务的情况下上线代码的部署方式。</p><p>和蓝绿部署不同的是，滚动部署对外提供服务的版本并不是非此即彼，而是在更细的粒度下平滑完成版本的升级。</p><p>如何做到细粒度平滑升级版本呢？</p><p>滚动部署只需要一个集群，集群下的不同节点可以独立进行版本升级。比如在一个16节点的集群中，我们选择每次升级4个节点：</p><p><img src="/2019/02/22/Git-Gitlab-Jenkins-2/%E6%BB%9A%E5%8A%A8%E6%9B%B4%E6%96%B0-1.jpg" alt></p><p><img src="/2019/02/22/Git-Gitlab-Jenkins-2/%E6%BB%9A%E5%8A%A8%E6%9B%B4%E6%96%B0-2.jpg" alt></p><p><img src="/2019/02/22/Git-Gitlab-Jenkins-2/%E6%BB%9A%E5%8A%A8%E6%9B%B4%E6%96%B0-3.jpg" alt></p><p><img src="/2019/02/22/Git-Gitlab-Jenkins-2/%E6%BB%9A%E5%8A%A8%E6%9B%B4%E6%96%B0-4.jpg" alt></p><p><strong>蓝绿部署与滚动更新对比</strong></p><table><thead><tr><th align="center">部署方式</th><th align="center">优势</th><th align="center">劣势</th></tr></thead><tbody><tr><td align="center">蓝绿部署</td><td align="center">1.同时间对外服务的只有一个版本，容易定位问题。2.集群式部署，较为简单。</td><td align="center">需维护两个集群，成本较高。</td></tr><tr><td align="center">滚动更新</td><td align="center">只需要维护一个版本，成本较低</td><td align="center">1.两个版本同时服务，不容易定位问题。2.升级和回滚以节点为单位，较复杂。</td></tr></tbody></table><h3 id="灰度发布（A-B测试、金丝雀部署）"><a href="#灰度发布（A-B测试、金丝雀部署）" class="headerlink" title="灰度发布（A/B测试、金丝雀部署）"></a>灰度发布（A/B测试、金丝雀部署）</h3><p>灰度发布是指在黑与白之间，能够平滑过渡的一种发布方式。</p><p>AB test就是一种灰度发布方式，让一部分用户继续用A，一部分用户开始用B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面来。</p><p>灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度，而我们平常所说的金丝雀部署也就是灰度发布的一种方式。</p><p><img src="/2019/02/22/Git-Gitlab-Jenkins-2/%E9%87%91%E4%B8%9D%E9%9B%80%E9%83%A8%E7%BD%B2.png" alt></p><p>灰度发布/金丝雀部署步骤：</p><ol><li>准备好部署各个阶段的工件，包括：构建工件，测试脚本，配置文件和部署清单文件。</li><li>从负载均衡列表中移除掉“金丝雀”服务器。</li><li>升级“金丝雀”应用（排掉原有流量并进行部署）。</li><li>对应用进行自动化测试。</li><li>将“金丝雀”服务器重新添加到负载均衡列表中（连通性和健康检查）。</li><li>如果“金丝雀”在线使用测试成功，升级剩余的其他服务器。（否则就回滚）</li></ol><p>除此之外灰度发布还可以设置路由权重，动态调整不同的权重来进行新老版本的验证。</p><h2 id="持续发布（CR）"><a href="#持续发布（CR）" class="headerlink" title="持续发布（CR）"></a>持续发布（CR）</h2><p><strong>Continuous Release，简称CR</strong></p><p>​    发布是周期性或不定期地对项目在部署后，进行整体软件版本的更新，例如，更新新功能或展示页面框架等。</p><p><strong>目的</strong></p><ol><li>产品的快速迭代，小步快跑</li><li>适应市场变化</li><li>匹配市场策略</li><li>应对市场风险</li></ol><h2 id="持续测试（CT）"><a href="#持续测试（CT）" class="headerlink" title="持续测试（CT）"></a>持续测试（CT）</h2><p><strong>Continuous Testing,简称CT</strong></p><p>​       持续测试是贯穿着整个软件开发过程，验证程序员提交代码，检验合规性及降低bug,减少最终错误，实现敏捷及精益开发。</p><p><strong>目的</strong></p><ol><li>为了降低开发、部署、发布等可能出现的错误</li><li>防止代码出错</li><li>防止功能出错</li><li>防止业务逻辑出错等</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Git-Gitlab-Jenkins-2-Gitlab&quot;&gt;&lt;a href=&quot;#Git-Gitlab-Jenkins-2-Gitlab&quot; class=&quot;headerlink&quot; title=&quot;Git+Gitlab+Jenkins_2(Gitlab)&quot;&gt;&lt;/a&gt;Git+
      
    
    </summary>
    
      <category term="Gitlab" scheme="https://www.opszn.com/categories/Gitlab/"/>
    
    
      <category term="CI/CD" scheme="https://www.opszn.com/tags/CI-CD/"/>
    
  </entry>
  
  <entry>
    <title>Git+Gitlab+Jenkins_1</title>
    <link href="https://www.opszn.com/2019/02/19/Git-Gitlab-Jenkins-1/"/>
    <id>https://www.opszn.com/2019/02/19/Git-Gitlab-Jenkins-1/</id>
    <published>2019-02-19T02:06:32.000Z</published>
    <updated>2019-08-14T08:08:10.410Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git-Gitlab-Jenkins-1（Git）"><a href="#Git-Gitlab-Jenkins-1（Git）" class="headerlink" title="Git+Gitlab+Jenkins_1（Git）"></a>Git+Gitlab+Jenkins_1（Git）</h1><p>随着公司的集群架构已经愈发的庞大，但应用服务器上的代码升级和新产品的发布效率不高，比如当代码发布到生产服务器后bug太多，客户反映比较强烈。公司的产品项目从需求分析,设计,研发,代码测试到发布上线的流程有问题，开发者开发的代码提交后有BUG没有反馈，运维也没有在测试环境下做有效地压力测试, 都是导致问题的原因。</p><p>因此我们要运用到devops（开发与运维工作有效结合）的思路，通过CI/CD(持续集成持续交付)来实现自动化的集成与交付工作。</p><h2 id="DevOps简述"><a href="#DevOps简述" class="headerlink" title="DevOps简述"></a>DevOps简述</h2><p>软件开发团队成员一般会包括项目经理，系统架构师、前端开发者，后端开发者，测试工程师，网络工程师，运维工程师等。软件先由后端开发者，前端开发者进行开发，当软件开发完成，需要部署时，软件会通过自动化手段达到系统架构师，运维工程师等这些运维人员的手上，由运维人员进行部署、发布即可。</p><p>如何让软件在开发、测试、运维及最终发布之间进行有效的流动，这就是DevOps所要关注的重点。</p><p>DevOps是整个IT架构实施中使用敏捷开发及精益原则的结果，利用精益原则可以使用开发与运维无缝结合。</p><p>DevOps是一种文化，一种理念，是一种把开发（Dev）、测试（Test）、运维（Ops）及最终发布（CR）工作流进行联合的思想。</p><p><strong>利用DevOps思想工作的三种方式及实践方法</strong></p><p><strong>第一种：系统思考</strong></p><p>强调全局优化，而非局部改进。<br>大到部门职能划分（例如研发部和运维部门），小到个人（开发和系统工程师）。</p><p>这种方式将关注点放在整个业务价值流上。换句话说，整个团队应该关注在从需求被定义到开发，再到运维这个过程，直到价值被以服务的形式交付给最终用户。</p><p>将这种方式带到实践中的产出便是永远不要将已知的缺陷传递到下游工作，永远不要为了局部优化影响了整体价值流交付，总是为了增加价值流动努力，永远追求对架构的深刻理解。</p><p>​        <strong>实践方法</strong></p><ul><li>所有环境和代码使用同一个仓库，将软件包纳入版本管理</li><li>团队共同决定发布流程</li><li>保持 DEV、TEST、PRODUCTION 环境的一致性</li><li>自动化回归测试</li><li>小步提交，每日部署；而不是一次部署大量变更 </li><li>更快、更频繁发布</li></ul><blockquote><p>回归测试是指修改了旧代码后，重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误。</p></blockquote><p><strong>第二种：放大反馈环</strong></p><p>​    创建从开发过程下游至上游的反馈环。几乎所有的流程改进都是为了从时间上缩短和从覆盖面上放大反馈循环，从而可以不断地进行必要的改正。</p><p>​    产出是关注到价值流中所有涉及到的用户，包括价值流内部和外部的，缩短和放大反馈回路，并且可以随时定位到需要改进的地方。</p><p>​        <strong>实践方法</strong></p><ul><li>代码审查及配置变更检查</li><li>有纪律的自动化测试，使许多同时的小型敏捷团队能够有效地工作</li><li>尽早设置监控预警</li><li>修复 bug 为团队最高优先级</li><li>团队成员之间高度互相信任</li><li>团队之间保持沟通和良好合作</li></ul><p>​    </p><p><strong>第三种：持续实验和学习的文化</strong></p><p>​    提倡持续做试验，承担风险、从失败中学习；通过反复实践来达到精通。</p><p>​    我们需要实验和冒着失败的风险，及时不断地尝试将我们置于一个危险的境地，我们要通过反复试错来掌握使我们远离危险的技能。</p><p>​        <strong>实践方法</strong></p><ul><li>对服务器正在承载的业务进行故障模拟，把人工错误引入系统中，加强系统的健壮性</li><li>生产中部署一台服务器用于进行故障训练，以便练习服务器经常处于失效状态下的故障恢复能力。</li></ul><h2 id="版本控制概念"><a href="#版本控制概念" class="headerlink" title="版本控制概念"></a>版本控制概念</h2><p>版本控制软件提供完备的<strong>版本管理功能</strong>，用于<strong>存储、追踪目录（文件夹）和文件的修改历史</strong>，是软件开发者的必备工具，是软件公司的基础设施。版本控制软件的最高目标，是支持软件公司的配置管理活动，追踪多个版本的开发和维护活动，及时发布软件。</p><p><img src="/2019/02/19/Git-Gitlab-Jenkins-1/1.png" alt></p><p><strong>常见的版本控制系统</strong></p><p>集中式版本控制系统：cvs,svn</p><p>分布式版本控制系统：git</p><p><strong>比较</strong></p><ul><li>集中式版本控制系统必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，你懂的。分布式版本控制系统可以不连网工作, 因为版本库就在你自己的电脑上。</li><li>集中式版本控制系统如果中央服务器挂了,就完蛋了。分布式版本控制系统可以没有中央服务器，每个人的电脑上都是一个完整的版本库，可靠性高。分布式版本控制系统也可以有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。</li></ul><h2 id="工作空间"><a href="#工作空间" class="headerlink" title="工作空间"></a>工作空间</h2><p><strong>1.设置身份</strong></p><p>在实际的开发环境当中，开发团队肯定不止一个人，而且git也没有智能识别使用者，这时候就需要开发人员自己设置一个身份，用于标识自己。身份设置如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> git config --global user.name <span class="string">"opszn"</span></span><br><span class="line"> git config --global user.email <span class="string">"mail@opszn.com"</span></span><br><span class="line"> git config --global color.ui true</span><br><span class="line"> </span><br><span class="line"> 设置完毕之后我们可以查看自己的身份信息</span><br><span class="line">[root@localhost ~]<span class="comment"># git config --list</span></span><br><span class="line">user.name=opszn</span><br><span class="line">user.email=mail@opszn.com</span><br><span class="line">color.ui=true</span><br></pre></td></tr></table></figure><p><strong>2.了解与部件原理</strong></p><p>工作目录：也可以叫做工作区，用于存放代码文件的一个目录。</p><p>仓库：版本库，在init初始化之后会生成一个.git的隐藏目录，我们也可以理解为就是版本库。仓库也分为本地仓库与远程仓库（gitlab，后面会提到）。</p><p><strong>了解git三大分区</strong></p><p>放图！</p><p><img src="/2019/02/19/Git-Gitlab-Jenkins-1/2.png" alt></p><p><strong>3.创建仓库</strong></p><ul><li><p>创建工作目录</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]mkdir opszn</span><br></pre></td></tr></table></figure></li><li><p>在目录中创建对应本地仓库</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cd opszn/</span></span><br><span class="line">[root@localhost opszn]<span class="comment"># git init</span></span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /root/opszn/.git/</span><br><span class="line">会产生一个.git子目录,所有除代码数据外的相关数据都在此目录,不要修改它.</span><br><span class="line">(它就是仓库或叫版本库)</span><br><span class="line">[root@localhost opszn]<span class="comment"># ls .git/</span></span><br><span class="line">branches  config  description  HEAD  hooks  info  objects  refs</span><br></pre></td></tr></table></figure></li></ul><h2 id="暂存区"><a href="#暂存区" class="headerlink" title="暂存区"></a><strong>暂存区</strong></h2><p>也叫做缓存区，我们在工作空间新建了一个文件，需要将其添加到暂存区。</p><p>暂存区会临时保存改动。</p><p><strong>添加文件到暂存区</strong></p><p>1.准备一个文件</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost opszn]<span class="comment"># cat 1.py </span></span><br><span class="line">print(<span class="string">"hello world"</span>)</span><br></pre></td></tr></table></figure><p>2.使用<code>git add</code>命令提交到暂存区（逆向操作为<code>git rm --cached 1.py</code>)</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost opszn]<span class="comment"># git add 1.py</span></span><br></pre></td></tr></table></figure><p>3.提交第一个文件后,版本库.git子目录里就多了一个index</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost opszn]<span class="comment"># ls .git/</span></span><br><span class="line">branches  config  description  HEAD  hooks  index  info  objects  refs</span><br></pre></td></tr></table></figure><p>4.使用<code>strings</code>命令查看可以看到<code>git add</code>的文件列表</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@vm2 opszn]<span class="comment"># strings .git/index </span></span><br><span class="line">DIRC</span><br><span class="line"><span class="number">1</span>.py这里可以看到<span class="number">1</span>.py文件添加到了index文件里了</span><br></pre></td></tr></table></figure><h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><p>代码文件需要commit提交后才纳入版本控制</p><p>对于我们之前的1.py文件，我们进行提交</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost opszn]<span class="comment"># git commit -m "提交1.py"      </span></span><br><span class="line">-m参数后接提交的版本信息</span><br><span class="line">[master (root-commit) <span class="number">4</span>e67190] 提交<span class="number">1</span>.py</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+)</span><br><span class="line"> create mode <span class="number">100644</span> <span class="number">1</span>.py</span><br><span class="line"> </span><br><span class="line"> 查看当前是否还有需要提交的文件</span><br><span class="line"> [root@localhost opszn]<span class="comment"># git status</span></span><br><span class="line"> nothing to commit, working directory clean</span><br></pre></td></tr></table></figure><p>查看状态后出现上述返回表示所有修改都纳入了版本控制。</p><p>其他命令</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">修改文件后查看修改内容</span><br><span class="line">git diff</span><br><span class="line">查看历史提交的版本信息</span><br><span class="line">git log</span><br><span class="line">查看提交的历史版本信息, 查看的显示信息更简洁。</span><br><span class="line">git log --pretty=oneline</span><br></pre></td></tr></table></figure><p><strong>小结:</strong> </p><ul><li>工作目录中写好的代码文件需要先<code>git add 文件名</code>添加到暂存区,再<code>git commit 文件名</code>提交。以后每次修改都要重复前两步。</li><li><code>git status</code>查看工作目录中的状态</li><li><code>git diff 文件名</code>查看文件修改了什么</li></ul><h2 id="版本回退与还原"><a href="#版本回退与还原" class="headerlink" title="版本回退与还原"></a>版本回退与还原</h2><p>1.回退到上一个版本</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure><p>2.还原到第3个版本</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 第<span class="number">3</span>个版本号</span><br><span class="line">查看所有操作历史（忘记版本号）</span><br><span class="line">git reflog</span><br></pre></td></tr></table></figure><p>3.回退到上上个版本</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^^</span><br></pre></td></tr></table></figure><p>4.回退到n个版本之前</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD~n</span><br></pre></td></tr></table></figure><p><strong>小结:</strong> </p><ul><li>提交后的代码文件，使用<code>git log</code>查看当前版本及以前的历史版本。</li><li>使用<code>git reset --hard HEAD^</code>或者<code>git reset --hard HEAD~100</code>实现版本回退。</li><li>使用<code>git reflog</code>查看提交的所有操作及版本号</li><li>使用<code>git reset --hard 版本号</code>你可以自由的在不同版本之间来回切换。</li></ul><p><strong>git工作流再次理解与应用拓展</strong></p><ul><li>工作目录里任何修改或增加的文件，都要git add到暂存区，让暂存区和工作目录的状态一致，这样才能提交一个版本。</li><li>git commit提交的是在暂存区里的所有文件状态。<strong>也就是说是整个工作目录里的状态保存为一个版本，而不是某一个文件</strong>。</li><li>git版本控制不仅仅是用于项目开发，你也可以用于一个软件包仓库的版本控制。</li></ul><h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><p>人为的工作总是不避免 会出现一些问题，对于开发人员来说，开发过程可能非常的漫长，那么假如有时候开发人员的状态不好，提交的代码非常的混乱也很多bug，这个时候撤销修改这个操作就显得尤为重要了。</p><p>想要撤销修改有以下方法:</p><ul><li>直接把写错的代码删除就好, 但如果改变的代码很多，开发者自己都忘了具体改了哪些代码，这种做法就不方便了</li><li>使用<code>git checkout -- 文件名</code>就可以直接撤销修改了</li><li>如果写乱了代码，添加暂存区但还没有commit提交。使用<code>git reset HEAD 文件名</code>取消暂存区添加，再<code>git checkout -- 文件名</code>来撤销修改</li><li>如果写乱了代码，添加暂存区并提交了。则使用版本回退</li></ul><h2 id="误删恢复"><a href="#误删恢复" class="headerlink" title="误删恢复"></a>误删恢复</h2><p>情况分类</p><ul><li>添加到了暂存区，无论有没有<code>git commit</code>提交。误删除后都可以使用 <code>git checkout -- 文件名</code>来恢复。</li><li>如果文件没有<code>git add</code>到暂存区, 误删除了就没了。</li></ul><h2 id="文件删除"><a href="#文件删除" class="headerlink" title="文件删除"></a>文件删除</h2><ul><li>没有<code>git add</code>到暂存区的文件<strong>直接rm删除就ok</strong>。</li><li>git add<code>添加到暂存区,但没有</code>git commit`提交的文件。需要<strong>rm删除本地,还要git rm 文件名删除</strong>。</li><li>git add<code>添加到暂存区,并且已经</code>git commit`提交的文件。需要<strong>rm删除本地,再git rm 文件名删除,最后再提交删除</strong>。</li></ul><h2 id="版本控制小结"><a href="#版本控制小结" class="headerlink" title="版本控制小结"></a>版本控制小结</h2><p><img src="/2019/02/19/Git-Gitlab-Jenkins-1/3.png" alt></p><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>开发团队可能分开开发模块，那么当A还未开发完成但是为了防止文件丢失就提交了，B并不知情就用了A的模块继续开发，这就造成了问题。</p><p>解决的方法：每个开发人员都有属于自己的分支，并且有一条主分支，当模块设计完毕，提交到主分支上，在由主分支的管理人员进行合并即可。图解如下：</p><p><img src="/2019/02/19/Git-Gitlab-Jenkins-1/4.png" alt></p><p>各分支之间不受影响，可以看作是平行空间。</p><h3 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h3><p>默认只有一个master分支, 前面有*号的代表为当前分支。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost opszn]<span class="comment"># git branch</span></span><br><span class="line">*master</span><br></pre></td></tr></table></figure><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost opszn]<span class="comment"># git branch tony</span></span><br><span class="line">[root@localhost opszn]<span class="comment"># git branch</span></span><br><span class="line">tony</span><br><span class="line">*master</span><br></pre></td></tr></table></figure><h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost opszn]<span class="comment"># git checkout tony</span></span><br><span class="line">Switched to branch <span class="string">'tony'</span></span><br><span class="line">[root@localhost opszn]<span class="comment"># git branch</span></span><br><span class="line">*tony</span><br><span class="line">master</span><br></pre></td></tr></table></figure><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><p>当我们使用tony进行commit提交的时候，在master分支上是看不到这个新提交的文件的，我们需要把tony分支上的文件与master进行合并。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost opszn]<span class="comment"># git merge tony</span></span><br><span class="line">Updating dc4ee5e..<span class="number">4</span>a0c78e</span><br><span class="line">...</span><br><span class="line">此时切换master分支就可以看到tony新提交的文件了</span><br></pre></td></tr></table></figure><h3 id="分支冲突"><a href="#分支冲突" class="headerlink" title="分支冲突"></a>分支冲突</h3><p>假设tony与master都对同一文件进行了修改操作并提交，合并时就出现了问题，我们需要手工解决这些冲突。</p><p>git使用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;,=========,&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>符号分割冲突的内容，手动删除这些符号，并修改成你想要的内容。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">解决冲突前:</span><br><span class="line">[root@localhost opszn]<span class="comment"># cat 5.py </span></span><br><span class="line">new feature</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">tony_file:v2</span><br><span class="line">=======</span><br><span class="line">master_file:v2</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; tony</span><br><span class="line"></span><br><span class="line">解决冲突后:</span><br><span class="line">[root@loalhost opszn]<span class="comment"># cat 5.py </span></span><br><span class="line">new feature</span><br><span class="line">冲突解决</span><br></pre></td></tr></table></figure><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><p>使用<code>git branch -d 分支名</code>来删除分支。<strong>注意: 不能删除当前使用的分支.</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Git-Gitlab-Jenkins-1（Git）&quot;&gt;&lt;a href=&quot;#Git-Gitlab-Jenkins-1（Git）&quot; class=&quot;headerlink&quot; title=&quot;Git+Gitlab+Jenkins_1（Git）&quot;&gt;&lt;/a&gt;Git+Gitlab+
      
    
    </summary>
    
      <category term="Git" scheme="https://www.opszn.com/categories/Git/"/>
    
    
      <category term="CI/CD" scheme="https://www.opszn.com/tags/CI-CD/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客主题题—_NexT-1</title>
    <link href="https://www.opszn.com/2018/12/12/Hexo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E9%A2%98%E2%80%94-Next-1/"/>
    <id>https://www.opszn.com/2018/12/12/Hexo博客主题题—-Next-1/</id>
    <published>2018-12-12T06:24:25.000Z</published>
    <updated>2019-07-14T12:03:26.910Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo博客主题—-NexT-1"><a href="#Hexo博客主题—-NexT-1" class="headerlink" title="Hexo博客主题—_NexT-1"></a>Hexo博客主题—_NexT-1</h1><h2 id="前情回顾"><a href="#前情回顾" class="headerlink" title="前情回顾"></a>前情回顾</h2><blockquote><p>国际惯例，我们还是来看看上次的文章里需要注意的地方：</p></blockquote><ol><li>在我们新建仓库时我们稍微的强调了了一下这个命名规则但是呢估计还是有小伙伴想要创新挑战一下， 诶还就不那么命名（嗯…和我当初看其他大神的文档一样）不过我们最终还是败给了现实还是用这样的命名方式，会省掉很多麻烦。那么点进去我们的仓库呢就可以看到我们其实是可以随时对我们仓库的名字进行一个更改操作的，这就很nice了，想操作的也比较简单，就不放图了，有问题欢迎留言咨询~</li><li>上文中各种什么配置啊链接啊之类的，过来人的建议多复制多粘贴再修改，手打实测很容易上头，当然了问题也不大，可能就是比较费键盘。</li></ol><h2 id="本文概要"><a href="#本文概要" class="headerlink" title="本文概要"></a>本文概要</h2><blockquote><p>如果前面的本地搭建以及远程部署都么得问题，那么我们就可以来着手搞一点花里胡哨的东西——<a href="https://hexo.io/themes/" target="_blank" rel="noopener">Hexo主题</a>，给出了官方主题网站哈，我采用的是Next主题。这里开始可能这个坑就比较多了，涉及版本啊，手残啊…总之代码手段极其残忍…但是不慌，因为我都基本踩完了…完了..了.    </p></blockquote><h2 id="Next"><a href="#Next" class="headerlink" title="Next"></a>Next</h2><blockquote><p>进入到我们的根目录（myblog），用git拉取主题到我们本地。需要更换自己心仪的主题选择自己想要的用ssh替换掉后面的<code>git@github.com/iissnan/hexo-theme-next.git</code></p></blockquote><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@github.com/iissnan/hexo-theme-next.git themes/next</span><br></pre></td></tr></table></figure><ol><li><p>下载成功后在根目录路径下themes下有next这个文件夹</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ls themes/next</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行上面命令可以看到有很多配置相关文件</span></span><br><span class="line">_config.yml  gulpfile.coffee  layout/  package.json  README.md  source/</span><br><span class="line">bower.json   languages/       LICENSE  README.cn.md  scripts/   test</span><br></pre></td></tr></table></figure></li><li><p><strong>主题更改-1：</strong>在根目录下修改<code>_config.yml_</code>配置文件先将我们的主题替换为next</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ vim _config.yml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找theme关键字，将其改为next</span></span><br><span class="line"></span><br><span class="line">theme： next     <span class="comment"># 注意这里的“theme：”后一定要有一个空格，这是yml文件的格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证的话还是老样子hexo素质三连,然后localhost看效果</span></span><br><span class="line">$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><p><img src="/2018/12/12/Hexo博客主题题—-Next-1/change_theme.png" alt></p></li><li><p><strong>主题更改-2：</strong>next给我们提供了四个不同样式的主题，我们可以根据个人的喜好进行设置</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ vim themes/next/_config.yml    <span class="comment"># 打开next主题配置文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找schemes 将想要更改的主题“#”去掉即可，但同事只可以开启一个主题所以我们默认的主题需要添加“#”</span></span><br><span class="line"><span class="comment"># 验证就不多赘述了，你懂的</span></span><br></pre></td></tr></table></figure><p><img src="/2018/12/12/Hexo博客主题题—-Next-1/next_themes.png" alt></p></li><li><p><strong>设置menu主页导航：</strong>默认生成的只有home和archives，我们按照个人需求进行添加</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ vim thmes/next/_config.yml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到menu。之后根据需求进行添加 ,需要打开的去掉注释“#”</span></span><br></pre></td></tr></table></figure><p><img src="/2018/12/12/Hexo博客主题题—-Next-1/add_menu.png" alt></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 虽然添加了menu但是我们发现访问的时候出现404，这时候我们需要初始化添加的页面</span></span><br><span class="line"></span><br><span class="line">$ hexo new page <span class="string">"xxx"</span>       <span class="comment"># xxx 为添加的menu，如hexo new page "tags"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次三连后就可以访问到各个页面了</span></span><br></pre></td></tr></table></figure></li><li><p><strong>修改添加页面类型：</strong>初始化之后我们还要对页面的类型进行定义</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ vim source/tags/index.md     </span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们以tags为例，其余新增的页面都要进行这样的操作,将类型与title对应</span></span><br></pre></td></tr></table></figure><p><img src="/2018/12/12/Hexo博客主题题—-Next-1/change_type_menu.png" alt></p></li><li><p><strong>添加“fock me  on github”:</strong></p><blockquote><p>我们可以在<a href="https://github.blog/2008-12-19-github-ribbons/" target="_blank" rel="noopener">GitHub Ribbons</a>或者<a href="http://tholman.com/github-corners/" target="_blank" rel="noopener">GitHub Corners</a>中根据个人喜好选择样式，再复制样式内代码(如下图红框内容，完全复制)</p></blockquote><p><img src="/2018/12/12/Hexo博客主题题—-Next-1/fockme.png" alt></p><blockquote><p>之后在<code>themes/next/layout/_layout.swig</code>文件里将代码粘贴进如即可，我的放在<code>&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;</code>下，下图白框处链接换为自己的github地址即可。</p></blockquote><p><img src="/2018/12/12/Hexo博客主题题—-Next-1/D:%5Chexo%5Cmyblog%5Csource_posts%5CHexo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E9%A2%98%E2%80%94-NexT-1%5Cfockme2.png" alt></p></li><li><p><strong>设置“fock me  on github”不在移动端显示：</strong></p><blockquote><p>经过实测我的blogtitle总是和这个图标有一些莫名的交集，逼死强迫症系列，所以我添加了不在移动端显示。</p></blockquote><p>7.1找到<code>themes/next/layout/_layout.swig</code>路径下的文件打开，也就是我们刚才添加fock me on github 的地方，找到对应的位置，添加如图代码：</p><p><img src="/2018/12/12/Hexo博客主题题—-Next-1/fock.png" alt></p><p>附上代码：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.fock&#123;</span><br><span class="line">diaplay: none;</span><br><span class="line">&#125;</span><br><span class="line">@media (min-width: <span class="number">768</span>px) &#123;</span><br><span class="line">.fock&#123;</span><br><span class="line">diaplay: inline;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li></ol><p>   之后在我们之前添加“fock..“的代码前调用class即可，具体如下图：</p><p>   <img src="/2018/12/12/Hexo博客主题题—-Next-1/fock-1.png" alt></p><p>   保存退出后再次三连在本地查看，我们选用的是chrome浏览器按下F12可以调试，下图我们看到在移动端已经不显示了。</p><p>   <img src="/2018/12/12/Hexo博客主题题—-Next-1/checkfock.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hexo博客主题—-NexT-1&quot;&gt;&lt;a href=&quot;#Hexo博客主题—-NexT-1&quot; class=&quot;headerlink&quot; title=&quot;Hexo博客主题—_NexT-1&quot;&gt;&lt;/a&gt;Hexo博客主题—_NexT-1&lt;/h1&gt;&lt;h2 id=&quot;前情回顾&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="NexT" scheme="https://www.opszn.com/categories/NexT/"/>
    
    
      <category term="NexT" scheme="https://www.opszn.com/tags/NexT/"/>
    
      <category term="Hexo" scheme="https://www.opszn.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Windows+Github搭建个Hexo博客网站-2</title>
    <link href="https://www.opszn.com/2018/12/11/Windows-Github%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99-2/"/>
    <id>https://www.opszn.com/2018/12/11/Windows-Github搭建Hexo博客网站-2/</id>
    <published>2018-12-11T02:10:40.000Z</published>
    <updated>2019-07-14T11:48:48.094Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Windows-Github搭建个Hexo博客网站-2"><a href="#Windows-Github搭建个Hexo博客网站-2" class="headerlink" title="Windows+Github搭建个Hexo博客网站-2"></a>Windows+Github搭建个Hexo博客网站-2</h1><h2 id="前情回顾"><a href="#前情回顾" class="headerlink" title="前情回顾"></a>前情回顾</h2><blockquote><p>在上一次的文章里，我们在win端也就是我们的本地环境搭建了一个Hexo的博客网站，回顾一下需要注意的地方：</p></blockquote><p><strong>1.</strong>nodejs也可以用npm的方式进行安装，npm从<a href="http://registry.npmjs.org" target="_blank" rel="noopener">国外的服务器</a>取到插件安装，所以即便是网速够快可能也会出现错误或者缓慢的现象，我们可以改用<a href="http://npm.taobao.org" target="_blank" rel="noopener">阿里的镜像服务器</a>进行安装，执行下述命令更改：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm config set registry https://registry.npm.taobao.org --global</span><br><span class="line">$ npm config set disturl https://npm.taobao.org/dist --global</span><br><span class="line">$ npm config get registry  <span class="comment">#查看本地源</span></span><br></pre></td></tr></table></figure><p>可以使用上述最后一条命令查看是否成功更换阿里镜像，之后我们就可以完全用cnpm替代npm进行安装升级等一系列的操作。</p><p><strong>2.</strong>在上文我们首先在D盘中创建了一个hexo目录，执行初始化<code>hexo init</code>操作的时候如果后面没有另外加博客名会安装在hexo目录下，看到“Start blogging with Hexo！”表示我们初始化就成功咯。</p><p><strong>3.</strong>开启服务器后浏览器本地访问不成功，端口问题，更换5000端口在次尝试，可以使用Ctrl + F5强制刷新网页。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s -p <span class="number">5000</span>    <span class="comment"># p是port的简写，端口的话可以自己定义</span></span><br></pre></td></tr></table></figure><h2 id="本期概要"><a href="#本期概要" class="headerlink" title="本期概要"></a>本期概要</h2><p><strong>远程部署Hexo实现公网环境访问</strong>（<strong>真·概要</strong>）</p><h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h2><blockquote><p>做开发的小伙伴应该是无人不知这个网站，那么对于运维来说应该也是哈，我们很多都可能用到GitHub或者GItlab比如CI/CD，扯远了，我们尽量保证颗粒度最小哈。好的我们进入正题，首先我们打开其<a href="https://github.com/" target="_blank" rel="noopener">官网</a>，默认主界面如下，我们按照我标注 的一步步进行注册然后登录就ok哈。</p></blockquote><p><img src="/2018/12/11/Windows-Github搭建Hexo博客网站-2/Github_signup.png" alt="Github_Sign-up"></p><p><strong>1.</strong>登录进去后可以看到提示创建新的Repositories也就是我们的仓库，我们根据下图创建新的仓库</p><p><img src="/2018/12/11/Windows-Github搭建Hexo博客网站-2/GitHub_Create_Repository.png" alt="GitHub_Create_Repository"></p><p><strong>2.</strong>创建之后点进入创建的仓库可以看到下图（临时做了一个新的test仓库看效果），我们需要用到这里的ssh 链接还有HTTPS，待会再说。</p><p><img src="/2018/12/11/Windows-Github搭建Hexo博客网站-2/New_Repos.png" alt="New_Repos"></p><h2 id="GIt-Bash"><a href="#GIt-Bash" class="headerlink" title="GIt Bash"></a>GIt Bash</h2><p><strong>1.</strong>我们在刚才创建了我们的GitHub账号以及仓库，那么现在回到我们的本地环境，还是选择我们的博客根目录（myblog），输入下面命令</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"username"</span>    <span class="comment"># username 为你的github账号名称</span></span><br><span class="line">$ git config --global user.email <span class="string">"useremail"</span>  <span class="comment"># useremail 为你注册的邮箱</span></span><br></pre></td></tr></table></figure><p><strong>2.</strong>接下来呢我们给自己的本地环境创建一对密钥对</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C  <span class="string">"email"</span>  <span class="comment">#此处email 为你注册的邮箱</span></span><br></pre></td></tr></table></figure><p><strong>3.</strong>注册完成会在C/Users/zn/.ssh中如下图（这里的zn是我自己的用户名，没有用户名的应该是Administrator）或者我们可以使用一个非常好用的搜索软件<a href="https://www.voidtools.com/" target="_blank" rel="noopener">Everything</a>搜索文件名id_rsa.pub</p><p><img src="/2018/12/11/Windows-Github搭建Hexo博客网站-2/sshkey.png" alt="ssh_key"></p><p><strong>4.</strong>这里我们要用到id_rsa.pub公钥文件，cat命令查看一下（Everything的朋友直接文件打开就行）复制公钥内容，在回到GItHub上，如下图</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat id_rsa.pub</span><br></pre></td></tr></table></figure><ol><li>点击GitHub右上角的个人头像</li><li>点击settings</li><li>找到并点击SSH  and GPG keys</li><li>点击New SSH key，粘贴公钥</li><li>提交</li></ol><p><img src="/2018/12/11/Windows-Github搭建Hexo博客网站-2/Add_sshkey.png" alt="add_sshkey"></p><p><strong>5.</strong>回到我们的Git Bash，输入下列命令,若有下图提示表示连接成功（opszn为我的用户名）。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure><p><img src="/2018/12/11/Windows-Github搭建Hexo博客网站-2/test_connection.png" alt="test_connection"></p><p><strong>6.</strong>配置本地根目录下_config.yml文件，找到Deployment并按照下图修改</p><p><img src="/2018/12/11/Windows-Github搭建Hexo博客网站-2/deploy.png" alt="deploy"></p><p><strong>7.</strong>接下来托管我们的网站到GItHub，下面命令输入后会出现需要需要输入GItHub用户名密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d -g  # 生成静态页面上传至Github</span><br></pre></td></tr></table></figure><p><strong>8.</strong>接下来输入链接到浏览器中即可实现公网环境访问。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://Yourname.github.io/  <span class="comment"># Yourname 为你的GItHub账号名</span></span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>至此，我们实现了公网环境下访问我们的博客网站了，下次的文章我们将对hexo进行系列设置美化，细数那些年踩过的美化坑（手动滑稽）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Windows-Github搭建个Hexo博客网站-2&quot;&gt;&lt;a href=&quot;#Windows-Github搭建个Hexo博客网站-2&quot; class=&quot;headerlink&quot; title=&quot;Windows+Github搭建个Hexo博客网站-2&quot;&gt;&lt;/a&gt;Windo
      
    
    </summary>
    
      <category term="Hexo" scheme="https://www.opszn.com/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://www.opszn.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Windows+Github搭建个Hexo博客网站-1</title>
    <link href="https://www.opszn.com/2018/12/09/Windows-Github%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99-1/"/>
    <id>https://www.opszn.com/2018/12/09/Windows-Github搭建Hexo博客网站-1/</id>
    <published>2018-12-09T06:45:45.000Z</published>
    <updated>2019-07-14T11:34:04.584Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Windows-Github搭建个Hexo博客网站-1"><a href="#Windows-Github搭建个Hexo博客网站-1" class="headerlink" title="Windows+Github搭建个Hexo博客网站-1"></a>Windows+Github搭建个Hexo博客网站-1</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h2><blockquote><p>偶然在了解到Hexo，感觉和Typecho或WordPress还是有蛮多的区别。于是兴致勃勃的搭建了一个博客网站，<a href="https://www.opszn.com/">点击上车</a>。那么期间也是磕磕绊绊的遇到很多的坑，也是结合和很多大佬的文档，那么在此呢还是想把我个人搭建时遇到的问题分享一下，希望可以帮助到在看的你。</p></blockquote><p><strong>原理：本地搭建Hexo博客网站，提交GitHub托管。</strong></p><h2 id="本地环境"><a href="#本地环境" class="headerlink" title="本地环境"></a>本地环境</h2><blockquote><p>本地的环境主要就是一个系统版本了，我的是Win10企业版。（cmd窗口中输入“winver”即可查看版本信息）</p></blockquote><p><img src="/2018/12/09/Windows-Github搭建Hexo博客网站-1/winver.jpg" alt="Verison of OS"></p><h2 id="需要用到的软件"><a href="#需要用到的软件" class="headerlink" title="需要用到的软件"></a>需要用到的软件</h2><p>git官方下载地址：<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a></p><p>nodejs官方下载地址: <a href="http://nodejs.cn/download/" target="_blank" rel="noopener">http://nodejs.cn/download/</a></p><p>hexo官方安装地址： <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a></p><h3 id="1-git安装："><a href="#1-git安装：" class="headerlink" title="1.git安装："></a>1.git安装：</h3><blockquote><p>git可在Win端提供一个类似Linux的操作命令行窗口，当然还负责与Github进行交互，这个后面再说。</p><p>那这个安装的话就不多赘述了，Win端安装你懂的，图形化安装不要太简单（不过要注意选择自己的安装路径，我是选择装到D盘，系统盘空间特别小的还是要注意换一个路径哈）。怎么才算安装成功呢，我们等安装结束后再桌面上单击一下鼠标右键，如果出现如下图红框中的两个图标，恭喜你已经安装成功。</p></blockquote><p>​                                                               <img src="/2018/12/09/Windows-Github搭建Hexo博客网站-1/git_client.png" alt="Git`installation success "></p><h3 id="2-nodejs安装："><a href="#2-nodejs安装：" class="headerlink" title="2.nodejs安装："></a>2.nodejs安装：</h3><blockquote><p>安装同上哈（但是注意安装过程中“Add to PATH”选项，默认勾上的但是检查一下记得勾上）同样的等待安装结束后验证是否安装成功。这里我们可以选择win + R 启用cmd输入</p></blockquote><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node -v </span><br><span class="line">$ npm -v</span><br></pre></td></tr></table></figure><blockquote><p>查看我们安装的版本信息，也可以用我们刚才安装的Git Bash 进行验证，我这里选用后者结果如下图。有相应的版本信息回复表示我们已经安装完成了，在此恭喜 ~</p></blockquote><p><img src="/2018/12/09/Windows-Github搭建Hexo博客网站-1/nodejs_i.png" alt="Nodejs`installation success "></p><h3 id="3-hexo安装："><a href="#3-hexo安装：" class="headerlink" title="3.hexo安装："></a>3.hexo安装：</h3><blockquote><p>在其官网上呢很简洁的给出了几条命令，我们一步步的来看。</p></blockquote><p><img src="/2018/12/09/Windows-Github搭建Hexo博客网站-1/hexo_i.png" alt="The sample order"></p><blockquote><p>我们还是需要用到Git Bash进行安装，但是安装之前呢我们需要选择一个路径哈（默认点开Git Bash工作空间是在C）选择D盘一个已经创建的目录（我的是hexo）</p></blockquote><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd D:hexo</span><br><span class="line">$ npm install hexo-cli -g</span><br></pre></td></tr></table></figure><blockquote><p>等待安装完成，按照惯例还是验证一下安装是否成功</p></blockquote><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo -v</span><br></pre></td></tr></table></figure><img src="/2018/12/09/Windows-Github搭建Hexo博客网站-1/hexo_v.png"><h3 id="4-hexo生成博客等操作："><a href="#4-hexo生成博客等操作：" class="headerlink" title="4.hexo生成博客等操作："></a>4.hexo生成博客等操作：</h3><blockquote><p>紧跟上一步，我们当前的工作目录是在D下hexo中，输入命令进行博客初始化等操作</p></blockquote><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init myblog  <span class="comment"># 初始化，这里的myblog是我自己定义的，可依照个人喜好更改</span></span><br><span class="line">$ cd myblog</span><br><span class="line">$ hexo generate     <span class="comment"># 生成静态页面，可以简写为hexo g</span></span><br><span class="line">$ hexo server       <span class="comment"># 开启服务器，可简写为hexo s(开启服务器的操作最好都在根目录下进行)</span></span><br></pre></td></tr></table></figure><blockquote><p>输入最后一条命令后我们会看到下图，留意最后一行的内容，http的链接就是我们本地的访问地址复制该链接到浏览器中即可（有些PC输入该链接无法访问，是因为本地占用了4000端口，我们可以更改一下端口信息比如<a href="http://localhost:5000" target="_blank" rel="noopener">http://localhost:5000</a> ,这样就能访问到hexo博客网站了），关闭服务器我们按照下面的提示选择Ctrl + C即可关闭本地服务器。</p></blockquote><p><img src="/2018/12/09/Windows-Github搭建Hexo博客网站-1/hexo_s.png" alt="Hexo server start &amp; stop"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><blockquote><p>至此，我们在本地的测试环境（或者说客户端环境就已经搭建完成），在下一篇文章中，我们将把我们的本地环境远程不熟到GIthub实现公网环境访问。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Windows-Github搭建个Hexo博客网站-1&quot;&gt;&lt;a href=&quot;#Windows-Github搭建个Hexo博客网站-1&quot; class=&quot;headerlink&quot; title=&quot;Windows+Github搭建个Hexo博客网站-1&quot;&gt;&lt;/a&gt;Windo
      
    
    </summary>
    
      <category term="Hexo" scheme="https://www.opszn.com/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://www.opszn.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>lvs负载均衡</title>
    <link href="https://www.opszn.com/2018/09/08/lvs%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>https://www.opszn.com/2018/09/08/lvs负载均衡/</id>
    <published>2018-09-08T08:33:24.000Z</published>
    <updated>2019-08-14T08:03:54.755Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LVS负载均衡"><a href="#LVS负载均衡" class="headerlink" title="LVS负载均衡"></a>LVS负载均衡</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>LVS（Linux Virtual Server）即Linux虚拟服务器，是由章文嵩博士主导的开源负载均衡项目，目前来说已经被集成到Linux内核模块中。该项目在Linux内核中实现了基于IP的数据请求负载均衡调度方案。LVS和IPVS在2.4版本之后的内核中已经集成，我们只需要安装ipvsadm管理工具即可。</p><p><strong>其特点有：</strong></p><ul><li>工作在网络层，属于四层负载均衡，可实现高性能高可用的服务器集群技术。</li><li>可拓展性好。</li><li>配置简单，使用方便，有多种负载均衡算法。</li><li>成本低，可以将多个性能较差的服务器做成一个超级服务器集群。</li><li>稳定可靠，集群中的某台故障，不会对正题集群产生影响。</li></ul><h2 id="2-常见的工作模式"><a href="#2-常见的工作模式" class="headerlink" title="2.常见的工作模式"></a>2.常见的工作模式</h2><table><thead><tr><th>工作模式</th><th>概义</th></tr></thead><tbody><tr><td>NAT</td><td>地址转换</td></tr><tr><td>DR</td><td>直接路由</td></tr><tr><td>TUN</td><td>隧道</td></tr><tr><td>FULLNAT</td><td>NAT+LocalIP</td></tr></tbody></table><p>常用的工作模式这里提两种：NAT和DR。</p><h2 id="3-算法概述"><a href="#3-算法概述" class="headerlink" title="3.算法概述"></a>3.算法概述</h2><p><strong>1.Fixed Scheduling Method 静态调度方法</strong></p><ul><li><p><strong>RR  轮询</strong></p><p>调度器通过”轮叫”调度算法将外部请求按顺序轮流分配到集群中的真实服务器上，它均等地对待每一台服务器，而不管服务器上实际的连接数和系统负载。</p></li><li><p><strong>WRR  加权轮询</strong></p><p>调度器通过”加权轮叫”调度算法根据真实服务器的不同处理能力来调度访问请求。 这样可以保证处理能力强的服务器处理更多的访问流量。调度器 可以自动问询真实服务器的负载情况，并动态地调整其权值。</p></li><li><p><strong>DH  目标地址hash</strong></p><p>算法也是针对目标IP地址的负载均衡，但它是一种静态映射算法，通过一个散列（Hash）函数将一个目标IP地址映射到一台服务器。<br>目标地址散列调度算法先根据请求的目标IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且未超载，将请求发送到该服务器，否则返回空。</p></li><li><p><strong>SH  源地址hash</strong></p><p>算法正好与目标地址散列调度算法相反，它根据请求的源IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是 可用的且未超载，将请求发送到该服务器，否则返回空。<br>它采用的散列函数与目标地址散列调度算法的相同。除了将请求的目标IP地址换成请求的源IP地址外，它的算法流程与目标地址散列调度算法的基本相似。在实际应用中，源地址散列调度和目标地址散列调度可以结合使用在防火墙集群中，它们可以保证整个系统的唯一出入口。</p></li><li><p><strong>LC  最少连接</strong></p><p>调度器通过”最少连接”调度算法动态地将网络请求调度到已建立的链接数最少的服务器上。 如果集群系统的真实服务器具有相近的系统性能，采用”最小连接”调度算法可以较好地均衡负载。</p></li><li><p><strong>WLC 加权最少连接</strong></p><p>在集群系统中的服务器性能差异较大的情况下，调度器采用”加权最少链接”调度算法优化负载均衡性能，具有较高权值的服务器将承受较大比例的活动连接负载。调度器可以自动问询真实服务器的负载情况，并动态地调整其权值。</p></li><li><p><strong>SED 最少期望延迟</strong></p><p>基于wlc算法，简单来说就是分发延迟最小的节点。</p></li><li><p><strong>NQ  从不排队调度方法</strong></p><p>无需列队，如果有台realserver的连接数=0 就直接分配过去，不需要进行sed运算。</p></li><li><p><strong>LBLC   基于本地的最少连接</strong></p><p>“基于局部性的最少链接” 调度算法是针对目标IP地址的负载均衡，目前主要用于Cache集群系统。<br>该算法根据请求的目标IP地址找出该 目标IP地址最近使用的服务器，若该服务器 是可用的且没有超载，将请求发送到该服务器；<br>若服务器不存在，或者该服务器超载且有服务器处于一半的工作负载，则用”最少链接”的原则选出一个可用的服务器，将请求发送到该服务器</p></li><li><p><strong>LBLCR   带复制的基于本地的最少连接</strong></p><p>“带复制的基于局部性最少链接”调度算法也是针对目标IP地址的负载均衡，目前主要用于Cache集群系统。<br>它与LBLC算法的不同 之处是它要维护从一个 目标IP地址到一组服务器的映射，而LBLC算法维护从一个目标IP地址到一台服务器的映射。<br>该算法根据请求的目标IP地址找出该目标IP地址对应的服务器组，按”最小连接”原则从服务器组中选出一台服务器，<br>若服务器没有超载，将请求发送到该服务器；若服务器超载，则按”最小连接”原则从这个集群中选出一 台服务器 ，将该服务器加入到服务器组中，将请求发送到该服务器。同时，当该服务器组有一段时间没有被修改， 将最忙的服务器从服务器组中删除，以降低复制的程度。</p></li></ul><h2 id="4-NAT模式"><a href="#4-NAT模式" class="headerlink" title="4.NAT模式"></a>4.NAT模式</h2><p>NAT模式主要在DS端做一个地址转换，那么它的拓扑如下：</p><p><img src="/2018/09/08/lvs负载均衡/nat.png" alt></p><p><strong>NAT原理解析：</strong></p><blockquote><p>1、用户请求VIP。<br>2、DS（Director Server） 收到用户的请求后,发现源地址请求的目标地址为VIP,那么DS会认为用户请求的是一个集群服务,那么DS会根据此前设定好的调度算法将用户请求负载给某台RS（Real Server）。假如说此时DS 根据调度的结果会将请求分摊到RS1上去,那么DS 会将用户的请求报文中的目标地址,从原来的VIP改为RS1的IP,然后再转发给RS1。<br>3、此时RS1收到一个源地址为CIP目标地址为自己的请求,那么RS1处理好请求后会将一个源地址为自己目标地址为用户IP的数据包通过DS 发出去。<br>4、当DS收到一个源地址为RS1 的IP 目标地址为CIP的数据包,此时Driector Server 会将源地址修改为VIP,然后再将数据包发送给用户。</p></blockquote><p><strong>配置详解：</strong></p><ul><li><p>RS节点修改网关地址为DS节点的DIP</p></li><li><p>DS安装ipvsadm进行相关配置</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义一个集群服务</span></span><br><span class="line"><span class="comment">#定义IP为VIP</span></span><br><span class="line">ipvsadm -A -t <span class="number">192.168</span>.<span class="number">24.52</span>:<span class="number">80</span> -s rr </span><br><span class="line"><span class="comment">#添加RealServer并指定工作模式为NAT</span></span><br><span class="line">ipvsadm -a -t <span class="number">192.168</span>.<span class="number">24.52</span>:<span class="number">80</span> -r <span class="number">192.168</span>.<span class="number">17.102</span> -m </span><br><span class="line">ipvsadm -a -t <span class="number">192.168</span>.<span class="number">24.52</span>:<span class="number">80</span> -r <span class="number">192.168</span>.<span class="number">17.101</span> -m</span><br><span class="line"><span class="comment">#查看ipvs定义的规则列表</span></span><br><span class="line">ipvsadm -L -n</span><br><span class="line"><span class="comment">#启动Linux的路由转发功能</span></span><br><span class="line">echo <span class="number">1</span> &gt; /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-DR模式"><a href="#5-DR模式" class="headerlink" title="5.DR模式"></a>5.DR模式</h2><p>DR模式下，返回请求不经过DS直接经由路由出，拓扑图如下：</p><p><img src="/2018/09/08/lvs负载均衡/dr.png" alt></p><p><strong>DR原理解析：</strong></p><blockquote><p>1、首先用户请求VIP</p><p>2、根据上图可以看到，不管是DR还是RS上都需要配置VIP，那么当用户请求到达我们的集群网络的前端路由器的时候，请求数据包的源地址为CIP目标地址为VIP，此时路由器会发广播问谁是VIP，那么我们集群中所有的节点都配置有VIP，此时谁先响应路由器那么路由器就会将用户请求发给谁，这样一来我们的集群系统是不是没有意义了，那我们可以在网关路由器上配置静态路由指定VIP就是DR，或者使用一种机制不让RS 接收来自网络中的ARP地址解析请求，这样一来用户的请求数据包都会经过Director Servrer</p><p>3、当DR收到用户的请求后根据此前设定好的调度算法结果来确定将请求负载到某台RS上去，假如说此时根据调度算法的结果，会将请求负载到RealServer 1上面去，此时DR 会将数据帧中的目标MAC地址修改为RS1的MAC地址,然后再将数据帧发送出去</p><p>4、当RS1 收到一个源地址为CIP目标地址为VIP的数据包时,RS1发现目标地址为VIP,而VIP是自己，于是接受数据包并给予处理，当RS1处理完请求后，会将一个源地址为VIP目标地址给CIP的数据包发出去，此时的响应请求就不会再经过DR了，而是直接响应给用户。</p></blockquote><p><strong>配置详解：</strong></p><ul><li><p>RS端配置：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置arp的通告模式  通过VIP请求到DS服务器</span></span><br><span class="line">echo <span class="number">1</span> &gt; /proc/sys/net/ipv4/conf/lo/arp_ignore</span><br><span class="line">echo <span class="number">2</span> &gt; /proc/sys/net/ipv4/conf/lo/arp_announce</span><br><span class="line">echo <span class="number">1</span> &gt; /proc/sys/net/ipv4/conf/all/arp_ignore</span><br><span class="line">echo <span class="number">2</span> &gt; /proc/sys/net/ipv4/conf/all/arp_announce</span><br><span class="line"><span class="comment">#绑定VIP到网卡</span></span><br><span class="line">ifconfig lo:<span class="number">0</span>  <span class="number">1.1</span>.<span class="number">1.100</span>  broadcast  <span class="number">1.1</span>.<span class="number">1.100</span> netmask <span class="number">255.255</span>.<span class="number">255.255</span> up</span><br><span class="line"><span class="comment">#添加主机路由</span></span><br><span class="line">route add -host  <span class="number">1.1</span>.<span class="number">1.100</span> dev lo:<span class="number">0</span></span><br></pre></td></tr></table></figure></li><li><p>DS端配置：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置DS上的VIP</span></span><br><span class="line">ifconfig eth0:<span class="number">0</span>  <span class="number">1.1</span>.<span class="number">1.100</span> broadcast  <span class="number">1.1</span>.<span class="number">1.100</span> netmask <span class="number">255.255</span>.<span class="number">255.255</span> up</span><br><span class="line"><span class="comment">#添加主机路由</span></span><br><span class="line">route add -host  <span class="number">1.1</span>.<span class="number">1.100</span> dev eth0:<span class="number">0</span></span><br><span class="line"><span class="comment">#配置转发规则</span></span><br><span class="line">ipvsadm -C</span><br><span class="line">ipvsadm -A -t  <span class="number">1.1</span>.<span class="number">1.100</span>:<span class="number">80</span> -s rr</span><br><span class="line">ipvsadm -a -t  <span class="number">1.1</span>.<span class="number">1.100</span>:<span class="number">80</span> -r <span class="number">1.1</span>.<span class="number">1.3</span> -g</span><br><span class="line">ipvsadm -a -t  <span class="number">1.1</span>.<span class="number">1.100</span>:<span class="number">80</span> -r <span class="number">1.1</span>.<span class="number">1.4</span> -g</span><br></pre></td></tr></table></figure></li></ul><h2 id="TIP"><a href="#TIP" class="headerlink" title="TIP"></a>TIP</h2><p>小结：</p><p>1.在配置lvs规则时，我们也可以将其写入/etc/sysconfig/ipvsadm文件中保存启用。</p><p>2.在使用DR模式时，由于DS与RS都配置了VIP，很可能请求会被分发至多个节点，一个是资源浪费严重，另外一个的话很可能返回客户端的数据会出现异常。解决的思路：可以在路由端配置静态路由指向DS；或者也可以在RS端配置RS不响应进来的ARP请求。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LVS负载均衡&quot;&gt;&lt;a href=&quot;#LVS负载均衡&quot; class=&quot;headerlink&quot; title=&quot;LVS负载均衡&quot;&gt;&lt;/a&gt;LVS负载均衡&lt;/h1&gt;&lt;h2 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="lvs" scheme="https://www.opszn.com/categories/lvs/"/>
    
    
      <category term="LoadBalance" scheme="https://www.opszn.com/tags/LoadBalance/"/>
    
  </entry>
  
  <entry>
    <title>业务节点高可用HA</title>
    <link href="https://www.opszn.com/2018/08/11/%E4%B8%9A%E5%8A%A1%E8%8A%82%E7%82%B9%E9%AB%98%E5%8F%AF%E7%94%A8HA/"/>
    <id>https://www.opszn.com/2018/08/11/业务节点高可用HA/</id>
    <published>2018-08-11T01:31:53.000Z</published>
    <updated>2019-08-14T08:04:21.435Z</updated>
    
    <content type="html"><![CDATA[<h1 id="业务节点高可用HA"><a href="#业务节点高可用HA" class="headerlink" title="业务节点高可用HA"></a>业务节点高可用HA</h1><h2 id="1-应用背景"><a href="#1-应用背景" class="headerlink" title="1.应用背景"></a>1.应用背景</h2><p>随着用户量增多，单台WEB服务器，压力越来越大。虽然单台WEB服务器，目前可以完成工作任务。但是如果一旦宕机，用户就完全失去服务了，用户体验特别不好。需要备用一台服务器进行使用，主服务器宕机之后，快速切换为备用服务器。</p><h2 id="2-keepalived简介"><a href="#2-keepalived简介" class="headerlink" title="2.keepalived简介"></a>2.keepalived简介</h2><p>Keepalived软件起初是专为LVS负载均衡软件设计的，用来管理并监控LVS集群系统中各个服务节点的状态，后来又加入了可以实现高可用的VRRP功能。因此，Keepalived除了能够管理LVS软件外，还可以作为其他服务（例如：Nginx、Haproxy、MySQL等）的高可用解决方案软件。</p><h2 id="3-keepalived原理"><a href="#3-keepalived原理" class="headerlink" title="3.keepalived原理"></a>3.keepalived原理</h2><p>Keepalived软件主要是通过VRRP协议实现高可用功能的。</p><p>VRRP是Virtual Router RedundancyProtocol(虚拟路由器冗余协议）的缩写，VRRP出现的目的就是为了解决静态路由单点故障问题的，它能够保证当个别节点宕机时，整个网络可以不间断地运行。</p><p>虚拟路由冗余协议，可以认为是实现路由器高可用的协议，即将N台提供相同功能的路由器组成一个路由器组，这个组里面有一个master和多个backup，master上面有一个对外提供服务的vip（该路由器所在局域网内其他机器的默认路由为该vip），master会发组播，当backup收不到vrrp包时就认为master宕掉了，这时就需要根据VRRP的优先级来选举一个backup当master。这样的话就可以保证路由器的高可用了。</p><h2 id="4-keepalived体系结构"><a href="#4-keepalived体系结构" class="headerlink" title="4.keepalived体系结构"></a>4.keepalived体系结构</h2><p>Keepalived的功能体系结构，大致分两层：<strong>用户空间（user space）和内核空间（kernel space）</strong>。</p><p><img src="/2018/08/11/业务节点高可用HA/5.png" alt></p><p><strong>内核空间：</strong></p><p>主要包括IPVS（IP虚拟服务器，用于实现网络服务的负载均衡）和NETLINK（提供高级路由及其他相关的网络功能）两个部份。</p><p><strong>用户空间：</strong></p><blockquote><p>WatchDog：负载监控checkers和VRRP进程的状况</p><p>VRRP Stack：负载均衡器之间的失败切换FailOver，如果只用一个负载均衡器，则VRRP不是必须的。</p><p>Checkers：负责真实服务器的健康检查healthchecking，是keepalived最主要的功能。换言之，可以没有VRRP Stack，但健康检查healthchecking是一定要有的。</p><p>IPVS wrapper：用户发送设定的规则到内核ipvs代码</p><p>Netlink Reflector：用来设定vrrp的vip地址等。</p></blockquote><p>keepalived主要使用三个模块，分别是core、check和vrrp。</p><p>core模块为keepalived的核心，负责主进程的启动、维护以及全局配置文件的加载和解析。</p><p>check负责健康检查，包括常见的各种检查方式。</p><p>vrrp模块是来实现VRRP协议的。</p><h2 id="5-部分配置说明"><a href="#5-部分配置说明" class="headerlink" title="5.部分配置说明"></a>5.部分配置说明</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/keepalived/keepalived.conf 配置文件位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#vrrp协议的配置</span></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    <span class="comment">#工作模式（主为master/备为backup）</span></span><br><span class="line">    state MASTER</span><br><span class="line">    <span class="comment">#监听的网卡</span></span><br><span class="line">    interface eth0</span><br><span class="line">    <span class="comment">#虚拟路由id 需要和备服务器一致</span></span><br><span class="line">    virtual_router_id <span class="number">51</span></span><br><span class="line">    <span class="comment">#权重 优先级</span></span><br><span class="line">    priority <span class="number">100</span></span><br><span class="line">    <span class="comment">#vrrp包的发送周期  1s</span></span><br><span class="line">    advert_int <span class="number">1</span></span><br><span class="line">    <span class="comment">#权限验证</span></span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass <span class="number">1111</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">#配置需要切换的VIP    </span></span><br><span class="line">virtual_ipaddress &#123;</span><br><span class="line">        <span class="number">1.1</span>.<span class="number">1.10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-脚本监测"><a href="#6-脚本监测" class="headerlink" title="6.脚本监测"></a>6.脚本监测</h2><p>通过keepalived可以直接实现主服务器整机不可用，实现VIP的切换。保证用户可以通过VIP进行访问服务。</p><p>但是实际情况下，往往并不是服务器整机不可用，只是对应的服务或者软件不可用。</p><p>比如说：nginx提供的web服务，nginx进程关闭，就需要检测当nginx不可用时，就切换VIP。</p><p><strong>实现过程分析：</strong></p><p>VIP实际是由keepalived进行绑定的，所以当nginx服务不可用时，就关闭当前机器的keepalived即可，释放VIP。进而绑定到其他备用服务器。</p><p>①编写服务检测脚本，实现检测nginx是否可用，不可用则关闭当前所在主机的keepalived</p><p>②在keepalived配置中调用检测服务脚本</p><p><strong>脚本实现：</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">nginx_status=`ps -C nginx --no-header | wc -l`</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$nginx_status</span> <span class="nomarkup">-eq</span> <span class="number">0</span> ];then</span><br><span class="line">   service keepalived stop</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p><strong>配置文件中编写触发脚本频率：</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在vrrp_instance外上面定义</span></span><br><span class="line">vrrp_script check_nginx &#123;</span><br><span class="line">   <span class="comment">#调用脚本地址</span></span><br><span class="line">   script  /etc/keepalived/check_nginx.sh</span><br><span class="line">   <span class="comment">#检测间隔时间</span></span><br><span class="line">   interval <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#在vrrp_instance里调用</span></span><br><span class="line">track_script &#123;</span><br><span class="line">    <span class="comment">#上线定义的名称</span></span><br><span class="line">    check_nginx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>业务场景下，用户是用过域名进行访问的，所以还需域名解析VIP即可。</p><h2 id="7-脑裂"><a href="#7-脑裂" class="headerlink" title="7.脑裂"></a>7.脑裂</h2><p><strong>表现：</strong>VIP同时出现在多个节点。</p><p><strong>原因：</strong>网络不通畅，禁用了数据包，主备服务器没法通讯，造成备服务器认为主服务器不可用，绑定VIP，主服务器VIP不会释放。</p><p><strong>解决方案：</strong></p><blockquote><ul><li><p>双备或者多备模式  BACKUP  通过priority权重来区分谁的优先级更高</p></li><li><p>单播(定向广播)的方式 (一些特定环境禁用了组播方式)</p></li><li><p>时间不同步  服务器时间校时</p></li></ul></blockquote><h2 id="8-非抢占模式"><a href="#8-非抢占模式" class="headerlink" title="8.非抢占模式"></a>8.非抢占模式</h2><p>当master宕机，VIP就切换到了备节点，那么当master重新启用服务后，VIP会被master重新抢占。实际情况下，我们不需要如此，主挂备为主，重启主为备。那么为了实现这样的目标，我们可以在主配置文件的vrrp_instance段中添加nopreempt，如：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line"> ...</span><br><span class="line"> state BACKUP</span><br><span class="line"> nopreempt</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，非抢占模式下所有节点都需要配置state为 BACKUP（即全为备）。</p><h2 id="9-单播模式"><a href="#9-单播模式" class="headerlink" title="9.单播模式"></a>9.单播模式</h2><p>默认情况下vrrp发送组播，但是不排除有特定环境下禁用了组播，那这时候就很容易造成脑裂，我们就要用到单播模式了。部分配置如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">主服务器部分配置</span><br><span class="line"><span class="comment">#在vrrp_instace段中加入</span></span><br><span class="line"><span class="comment">#本地IP</span></span><br><span class="line">unicast_src_ip <span class="number">1.1</span>.<span class="number">1.10</span></span><br><span class="line">unicast_peer &#123;</span><br><span class="line">    <span class="comment">#对象IP  发送vrrp包给备服务器</span></span><br><span class="line">    <span class="number">1.1</span>.<span class="number">1.11</span></span><br><span class="line">&#125;</span><br><span class="line">备服务器部分配置</span><br><span class="line">unicast_src_ip <span class="number">1.1</span>.<span class="number">1.11</span></span><br><span class="line">unicast_peer &#123;</span><br><span class="line"><span class="number">1.1</span>.<span class="number">1.10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TIP"><a href="#TIP" class="headerlink" title="TIP"></a>TIP</h2><p>为了验证，可以使用tcpdump 抓vrrp包：<code>tcpdump vrrp -n</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;业务节点高可用HA&quot;&gt;&lt;a href=&quot;#业务节点高可用HA&quot; class=&quot;headerlink&quot; title=&quot;业务节点高可用HA&quot;&gt;&lt;/a&gt;业务节点高可用HA&lt;/h1&gt;&lt;h2 id=&quot;1-应用背景&quot;&gt;&lt;a href=&quot;#1-应用背景&quot; class=&quot;head
      
    
    </summary>
    
      <category term="keepalived" scheme="https://www.opszn.com/categories/keepalived/"/>
    
    
      <category term="HA" scheme="https://www.opszn.com/tags/HA/"/>
    
  </entry>
  
  <entry>
    <title>Nginx负载均衡</title>
    <link href="https://www.opszn.com/2018/07/16/Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>https://www.opszn.com/2018/07/16/Nginx负载均衡/</id>
    <published>2018-07-16T06:46:44.000Z</published>
    <updated>2019-08-14T08:00:39.087Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nginx负载均衡"><a href="#Nginx负载均衡" class="headerlink" title="Nginx负载均衡"></a>Nginx负载均衡</h1><h2 id="1-Nginx简介"><a href="#1-Nginx简介" class="headerlink" title="1.Nginx简介"></a>1.Nginx简介</h2><p>Nginx采用C编写，是一种高性能的web服务器/反向代理服务器，可以在大多数Linux/Unix OS上运行。</p><p><strong>其优点主要有：</strong></p><p><code>1.</code>轻量：同样的web服务，会占用更少的内存及资源。</p><p><code>2.</code>高并发：在qps很高的情况下nginx也会保持资源的低消耗与高性能，而Apache在同等情况下线程数飙升甚至拒绝服务。</p><p><code>3.</code>静态文件处理性能较强：性能大约是Apache的3倍。</p><p><code>4.</code>nginx还是一个反向代理服务器，能够实现负载均衡LB，支持七层负载均衡，应用相比于lvs（四层）广泛许多。</p><p><code>5.</code>配置简单，启动前还有”-t“参数测试。</p><p><code>6.</code>高度模块化，模块编写相对简单。</p><p><code>7.</code>启动方便，服务持久化，几个月不出问题很正常。</p><p><code>8.</code>支持热部署，平滑升级。</p><p><strong>那么缺点呢：</strong></p><p><code>1.</code>不适合处理动态请求。</p><p><code>2.</code>rewrite高时性能不如Apache。</p><p><code>3.</code>bug较多，不如Apache稳定。</p><h2 id="2-Nginx-Apache反向代理"><a href="#2-Nginx-Apache反向代理" class="headerlink" title="2.Nginx+Apache反向代理"></a>2.Nginx+Apache反向代理</h2><p>上面我们说到nginx处理静态请求性能是远超Apache的，但是在处理动态请求时就显得有些缓慢，所以我们可以在原有架构中在增加Apache专门用于处理动态请求，这样可以解决LNMP中由于php-fpm产生的错误。</p><p>简单的配置流程如下：</p><p>Apache监听8080（除80外未被占用端口均可）———&gt; Nginx的location中配置proxy_pass为localhost：8080</p><h2 id="3-Nginx7层负载均衡"><a href="#3-Nginx7层负载均衡" class="headerlink" title="3.Nginx7层负载均衡"></a>3.Nginx7层负载均衡</h2><p>nginx本身是可以做7层的LB，基于URL或者主机IP等，属于反向代理的一种。</p><p><strong>相比于四层负载均衡的优势有：</strong></p><p><code>1.</code>可识别DDOS攻击，防御SYN cookies和SYN flood等。</p><p><code>2.</code>可实现session保持，图片压缩，防盗链等。</p><p><code>3.</code>安全性高。</p><p><strong>相关配置：</strong></p><p><code>1.</code>nginx配置文件内</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在http段进行配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#分发请求到后端服务器(ip为RSip，XX_name自定义)</span></span><br><span class="line"></span><br><span class="line">upstream XX_name &#123;</span><br><span class="line">    <span class="comment">#RS1</span></span><br><span class="line">    server <span class="number">1.1</span>.<span class="number">1.1</span> backup;</span><br><span class="line">    <span class="comment">#RS2</span></span><br><span class="line">    server <span class="number">1.1</span>.<span class="number">1.2</span>  weight=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#修改之前的XX_name的server段配置</span></span><br><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">80</span>；</span><br><span class="line">    server_name www.XX_name.com;</span><br><span class="line">    location / &#123;</span><br><span class="line">        <span class="comment">#代理转发到XX_name段  匹配到上面的upstream</span></span><br><span class="line">        proxy_pass http://XX_name;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#以下两条配置，实质是设置了传输的header头信息  </span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#传输域名给后端服务器  进行识别  方便匹配对应server虚拟主机</span></span><br><span class="line">        proxy_set_header Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="comment">#发送客户端IP  给后端服务器  用来方便后端服务器识别用户真实IP</span></span><br><span class="line">        proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>2.</code>server关键字</p><p>在上图配置的upstream中，可以看到RS1server下有“backup”关键字，关键字主要用于匹配分发规则。</p><table><thead><tr><th>关键字</th><th>解释</th></tr></thead><tbody><tr><td>backup</td><td>其他的backup标识server都未被分发，则分发至此backup</td></tr><tr><td>down</td><td>不分发给此RSserver</td></tr></tbody></table><p><code>3.</code>nginx负载均衡算法</p><p>nginx有自己的负载均衡算法，主要三种。</p><table><thead><tr><th>算法</th><th>解释</th></tr></thead><tbody><tr><td>RR（Round-Robin）默认算法</td><td>轮询，通俗来说就是一次请求分发一个RS集群的随机节点</td></tr><tr><td>weight</td><td>权重，节点的权重占比高分发的就高</td></tr><tr><td>ip_hash</td><td>同一个ip，所有访问都分发到同一个节点</td></tr></tbody></table><p>当然了除了官方的算法外，由于nginx高度模块化的优点，我们编译第三方模块也是可以实现一些算法的。</p><table><thead><tr><th>算法</th><th>解释</th></tr></thead><tbody><tr><td>fair</td><td>根据后端RS集群的繁忙程度，分发给当前非繁忙的节点</td></tr><tr><td>url_hash</td><td>如果访问的url是同一个，则转发到同一个后端的节点</td></tr></tbody></table><p><code>4.</code>session一致性</p><p>当用nginx实现了负载均衡之后呢，假设需要进行一些验证码的验证时，输入后提交分发了另外的RS，那么这个时候新的验证码就产生了，新的session也产生了，刚才输入的验证码就是错误的。就好比呢，就比如说我拿了一把钥匙开门，当我找到对的钥匙准备开门，门锁却换了另一副。诶，我再换新的钥匙， 它又换了新的，这就导致我们永远打不开这个门。那么这个时候，session一致性就显得尤为重要了。这里我们结合上述的算法来看，ip_hash将是为我们解决问题的关键，那么这就又要提到nginx配置简单的有点了，我们来看一下配置相关。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">upstream XX_name &#123;</span><br><span class="line">    ip_hash;  <span class="comment"># 只至需要在upstream段配置一行即可</span></span><br><span class="line">    <span class="comment">#RS1</span></span><br><span class="line">    server <span class="number">1.1</span>.<span class="number">1.1</span> weight=<span class="number">5</span>;</span><br><span class="line">    <span class="comment">#RS2</span></span><br><span class="line">    server <span class="number">1.1</span>.<span class="number">1.2</span>  weight=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么顺带呢在提一下weight，在上面的配置中，我们对RS设置了不同的权重，目前的算法就属于加权轮询算法，那么具体的访问中分发呢，假设我们访问了8次，那么5次将分发给RS1，3次将分发给RS2。</p><h2 id="TIP"><a href="#TIP" class="headerlink" title="TIP"></a>TIP</h2><p>小结一下，nginx的负载均衡算法实际上只是做了一个简单的分发，感觉上距离真正的负载均衡还是有一定的区别。而且当我们设置了ip_hash 保证了session一致性的时候，如果大量的用户通过同一个公网ip进行访问的话，分发也就不存在了，那么对于后台的某一台RS节点来说，访问量就会很大，而其他的饿节点就很空闲，负载均衡就没有起到作用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Nginx负载均衡&quot;&gt;&lt;a href=&quot;#Nginx负载均衡&quot; class=&quot;headerlink&quot; title=&quot;Nginx负载均衡&quot;&gt;&lt;/a&gt;Nginx负载均衡&lt;/h1&gt;&lt;h2 id=&quot;1-Nginx简介&quot;&gt;&lt;a href=&quot;#1-Nginx简介&quot; class
      
    
    </summary>
    
      <category term="Nginx" scheme="https://www.opszn.com/categories/Nginx/"/>
    
    
      <category term="LoadBalance" scheme="https://www.opszn.com/tags/LoadBalance/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.opszn.com/2018/03/05/%E7%BC%93%E5%AD%98%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8Bredis/"/>
    <id>https://www.opszn.com/2018/03/05/缓存中间件之redis/</id>
    <published>2018-03-05T01:32:46.000Z</published>
    <updated>2019-08-15T07:41:06.434Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缓存中间件之redis"><a href="#缓存中间件之redis" class="headerlink" title="缓存中间件之redis"></a>缓存中间件之redis</h1><h2 id="redis介绍"><a href="#redis介绍" class="headerlink" title="redis介绍"></a>redis介绍</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>1.Nosql 非关系数据库 key =&gt; value  键值对。</p><p>2.Redis是<strong>R</strong>emote <strong>D</strong>ictionary <strong>S</strong>erver(远程数据服务)的缩写。</p><p>3.由意大利人 antirez(Salvatore Sanfilippo)  开发的一款 内存高速缓存数据库。</p><p>4.该软件使用C语言编写,它的数据模型为 key-value。</p><p>5.它支持丰富的数据结构，比如 <strong>String，list（双向链表），  hash（哈希），  set（集合），  sorted set（zset有序集合）</strong>。</p><p>6.可持久化（保存数据到磁盘中），保证了数据安全。</p><h3 id="业务场景使用"><a href="#业务场景使用" class="headerlink" title="业务场景使用"></a>业务场景使用</h3><table><thead><tr><th>数据类型</th><th>应用类型</th></tr></thead><tbody><tr><td>string</td><td>计数器应用</td></tr><tr><td>list</td><td>某个分类的最新数据</td></tr><tr><td>sorted set</td><td>排行榜，热门话题等</td></tr><tr><td>set(sns)</td><td>获取朋友圈共同好友(social network site)</td></tr><tr><td>set</td><td>防攻击系统，黑白名单等</td></tr></tbody></table><h3 id="对比memcached"><a href="#对比memcached" class="headerlink" title="对比memcached"></a>对比memcached</h3><table><thead><tr><th>redis</th><th>memcached</th></tr></thead><tbody><tr><td>数据类型丰富（string，set，list，sorted list， hash）</td><td>数据类型单一（k,v）</td></tr><tr><td>缓存存放内存，还有aof与快照两种方式写入磁盘，实现数据持久化，重启仍存在</td><td>只放内存，关机清空</td></tr><tr><td>支持主从架构应用</td><td></td></tr><tr><td>单个value最大为512m</td><td>1m</td></tr><tr><td>单线程</td><td>多线程</td></tr></tbody></table><p>​    由于redis只能使用单核，而memcached可以使用多核，所以在比较上，平均每一个核上redis在储存小数据时比memcached性能更高。而却100K以上数据中，memcached性能要高于redis，虽然redis最近也在储存大数据的性能上进行优化，但是比起memcached还是有点逊色。结论是无论你使用那个，每秒处理请求的次数都不会成为瓶颈。</p><p>你需要关注内存使用率。对于key-vlaue这样简单的数据储存，memcached的内存使用率更高，如果采用hash结构，redis的内存使用率会更高，当然这都依赖于具体的应用场景。</p><h2 id="数据结构类型解析"><a href="#数据结构类型解析" class="headerlink" title="数据结构类型解析"></a>数据结构类型解析</h2><h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>key的命名规则不同于一般语言，键盘上除了空格、/n换行外其他的大部分字符都可以使用</p><p>​    像“my key”和“mykey/n”这样包含空格和换行的key是不允许的。</p><p>我们在使用的时候可以自己定义一个Key的格式。</p><p>例如 object-type:id:field</p><p>Key不要太长。占内存，查询慢。</p><p>Key不要太短。像u:1000:pwd:123456   就不如   user:1000:password:123456  可读性好</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>string是redis最基本的类型</p><p>redis的string可以包含任何数据。包括jpg图片 base64或者序列化的对象</p><p>单个value值最大上限是512MB</p><p>如果只用string类型，redis就可以被看作加上持久化特性的memcached</p><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>key value(value1,value2,value3)</p><p>list类型其实就是一个双向链表。通过push,pop操作从链表的头部或者尾部添加删除元素</p><p>这使得list既可以用作栈，也可以用作队列</p><p>同一端进出  先进后出   栈</p><p>一端  另外一端出  先进先出  队列</p><p><img src="/2018/03/05/缓存中间件之redis/wps83.jpg" alt> <img src="/2018/03/05/缓存中间件之redis/wps84.jpg" alt></p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>redis的set是string类型的无序集合。集合里不允许有重复的元素</p><p>set元素最大可以包含(2的32次方-1)个元素。</p><p>关于set集合类型除了基本的添加删除操作，其他常用的操作还包含集合的取并集(union)，交集(intersection)，差集(difference)。通过这些操作可以很容易的实现sns中的好友推荐功能。</p><p>Tip:mysql连表文氏图</p><p><a href="https://www.cnblogs.com/sunjie9606/p/4167190.html" target="_blank" rel="noopener">https://www.cnblogs.com/sunjie9606/p/4167190.html</a></p><h3 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h3><p>和set一样sorted set也是string类型元素的集合，有序集合，元素不允许重复</p><p>不同的是每个元素都会关联一个权。</p><p>通过权值可以有序的获取集合中的元素，可以通过score值进行排序</p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>使用redis做缓存，可以使用hash结构，压缩效率和使用效率更高，比string</p><p>Hash存储数据和关系型数据库（mysql），存储的一条数据的结构极为相似</p><p>Key：value（field：value）</p><h2 id="数据持久化操作"><a href="#数据持久化操作" class="headerlink" title="数据持久化操作"></a>数据持久化操作</h2><p>数据  持久化（数据在服务或者软件重启之后不丢失）</p><p>如果数据只存在内存中，肯定会丢失，实现持久化，就需要把数据存储到磁盘中（hdd ssd）</p><h3 id="snapshoting-快照"><a href="#snapshoting-快照" class="headerlink" title="snapshoting(快照)"></a>snapshoting(快照)</h3><p>默认snappshoting是开启的，有一个<strong>备份的频率</strong></p><p>通过查看配置文件可以看到</p><p><img src="/2018/03/05/缓存中间件之redis/wps113.jpg" alt></p><p><strong>备份文件</strong></p><p><img src="/2018/03/05/缓存中间件之redis/wps114.jpg" alt></p><p><strong>手动数据备份</strong></p><p>127.0.0.1:6379&gt; SAVE</p><p>数据恢复  需要先停掉redis服务</p><p>如果需要恢复数据，只需将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可</p><h3 id="append-only-file（aof）"><a href="#append-only-file（aof）" class="headerlink" title="append only file（aof）"></a>append only file（aof）</h3><p><strong>备份频率</strong></p><p><img src="/2018/03/05/缓存中间件之redis/wps119.jpg" alt></p><table><thead><tr><th>类型</th><th>解释</th></tr></thead><tbody><tr><td>appendfsync always</td><td>每次收到写命令就立即写入磁盘，最慢，数据完全持久化，不推荐</td></tr><tr><td>appendfsync everysec</td><td>每秒强制写入磁盘一次，在性能和数据完整性上做了折中，推荐</td></tr><tr><td>appendfsync no</td><td>完全依赖os，性能最好，但是持久化没有保证</td></tr></tbody></table><p><strong>总结：</strong></p><p>snappshoting 一般的数据持久化使用，效率高，数据迁移方便</p><p>aof 适合于备份、数据实时性备份要求更高的情况</p><h2 id="主从模式搭建思路"><a href="#主从模式搭建思路" class="headerlink" title="主从模式搭建思路"></a>主从模式搭建思路</h2><p>1.master在redis配置文件中的  <strong>“bind”行</strong>  监听自己对外访问的ip</p><p>2.slave在redis配置文件中的 <strong>“slaveof ”行</strong>  写上需要master的ip与端口。5.0版本之后，slaveof 改为了replicaof。</p><p>3.slave不允许写操作，因为配置文件中有 <strong>“slave-read-only  yes”</strong></p><h2 id="安全限制"><a href="#安全限制" class="headerlink" title="安全限制"></a>安全限制</h2><h3 id="ip限制登录"><a href="#ip限制登录" class="headerlink" title="ip限制登录"></a>ip限制登录</h3><p>1.同样的是在配置文件的  <strong>“bind”行</strong>  绑定需要限制登录的ip</p><p>2.在远程使用刚才绑定的ip进行登录测试</p><h3 id="密码验证"><a href="#密码验证" class="headerlink" title="密码验证"></a>密码验证</h3><p>1.配置文件中   <strong>“requirepass ”</strong>   后写上需要设置的密码</p><p>2.主从架构中，master设置了密码，那么slave也需要在配置文件 的  <strong>“masterauth”</strong> 后加上master的密码。</p><h3 id="session存入redis"><a href="#session存入redis" class="headerlink" title="session存入redis"></a>session存入redis</h3><p>还是以tp5shop为例，我们需要将session开启并且指向redis，如图</p><p><img src="/2018/03/05/缓存中间件之redis/wps144.jpg" alt></p><h3 id="Nginx-lua-redis-实现访问攻击黑名单-WAF"><a href="#Nginx-lua-redis-实现访问攻击黑名单-WAF" class="headerlink" title="Nginx+lua+redis 实现访问攻击黑名单   WAF"></a>Nginx+lua+redis 实现访问攻击黑名单   WAF</h3><ul><li><p><strong>安装openresty</strong></p></li><li><p><strong>配置文件</strong></p><p><img src="/2018/03/05/缓存中间件之redis/wps97.jpg" alt></p></li><li><p><strong>lua脚本</strong></p><p><img src="/2018/03/05/缓存中间件之redis/wps98.jpg" alt></p><p><img src="/2018/03/05/缓存中间件之redis/wps99.jpg" alt></p></li><li><p>测试访问超过10次，禁止访问</p><p><img src="/2018/03/05/缓存中间件之redis/wps100.jpg" alt></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;缓存中间件之redis&quot;&gt;&lt;a href=&quot;#缓存中间件之redis&quot; class=&quot;headerlink&quot; title=&quot;缓存中间件之redis&quot;&gt;&lt;/a&gt;缓存中间件之redis&lt;/h1&gt;&lt;h2 id=&quot;redis介绍&quot;&gt;&lt;a href=&quot;#redis介绍&quot; c
      
    
    </summary>
    
      <category term="redis" scheme="https://www.opszn.com/categories/redis/"/>
    
    
      <category term="缓存中间件" scheme="https://www.opszn.com/tags/%E7%BC%93%E5%AD%98%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>缓存中间件之memcached</title>
    <link href="https://www.opszn.com/2018/03/01/%E7%BC%93%E5%AD%98%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8Bmemcached/"/>
    <id>https://www.opszn.com/2018/03/01/缓存中间件之memcached/</id>
    <published>2018-03-01T02:21:46.000Z</published>
    <updated>2019-08-15T03:32:37.799Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缓存中间件之memcached"><a href="#缓存中间件之memcached" class="headerlink" title="缓存中间件之memcached"></a>缓存中间件之memcached</h1><h2 id="网站优化"><a href="#网站优化" class="headerlink" title="网站优化"></a>网站优化</h2><p>根据网页的访问流程，可以进行以下优化：</p><p>①提高web服务器并发  负载均衡（多台服务器架构） nginx。</p><p>②页面静态化  把经常访问，但是数据不经常发生变动的动态页面，制作为静态页面。</p><p>③内存缓存优化   把经常访问的数据，加载到内存中使用。</p><p>④数据库优化   很多时候，还需要取数据库信息，所以优化数据库本身。</p><h2 id="应用背景"><a href="#应用背景" class="headerlink" title="应用背景"></a>应用背景</h2><p>随着业务量增加，访问量越来越大，用户在访问某些页面数据时，通过慢查询日志发现慢查询SQL，经过优化之后效果还是不够明显。而此类数据发生变动的频率又较小，故提出使用缓存中间件（一般会将数据存储到内存中）的方式，降低MySQL的读压力，提高整个业务架构集群的稳定和快速响应能力。</p><h2 id="memcached"><a href="#memcached" class="headerlink" title="memcached"></a>memcached</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h3><p>Memcached 是国外 社区 网站 LiveJournal  的开发团队开发的 高性能的分布式内存缓存服务器。一般的使用目的是，通过缓存数据库查询结果，减少数据库访问次数，以提高动态 Web 应用的速度、提高可扩展性。关于缓存的过期，有效期问题，由业务编程代码实现。</p><p><img src="/2018/03/01/缓存中间件之memcached/1.png" alt></p><h3 id="软件参数解析"><a href="#软件参数解析" class="headerlink" title="软件参数解析"></a>软件参数解析</h3><blockquote><p>-p是设置Memcache监听的端口，最好是1024以上的端口；</p><p>-d是启动一个守护进程；</p><p>-m是分配给Memcache使用的内存数量，单位是MB；</p><p>-u是运行Memcache的用户；</p><p>-l是监听的服务器IP地址，可以有多个地址；</p><p>-c是最大运行的并发连接数，默认是1024；</p><p>-P是设置保存Memcache的pid文件</p></blockquote><h3 id="连接操作"><a href="#连接操作" class="headerlink" title="连接操作"></a>连接操作</h3><ul><li><p>Telnet连接，默认端口为11211.</p></li><li><p>存储命令</p><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td>set（存储命令）</td><td>将value1设置新的key，若key存在则更新对应源有数据为value1</td></tr><tr><td>flag</td><td>服务压缩器端标识，如flag（0,1）0不压缩，1压缩</td></tr><tr><td>add</td><td>将value1设置新的key若key存在不更新该key对应值，响应NOT_STORED</td></tr><tr><td>replace</td><td>替换已存在key的value,若key不存在则替换失败，响应NOT_STORED</td></tr><tr><td>append</td><td>对已存在key的value进行末尾追加数据</td></tr><tr><td>prepend</td><td>对已存在key的value进行首部追加</td></tr><tr><td>delete（删除命令）</td><td>删除已存在的key</td></tr><tr><td>flush_all</td><td>清空所有缓存（业务环境禁止使用此命令）</td></tr><tr><td>get（查找命令）</td><td>获取存储在 key(键) 中的 value(数据值) ，如果 key 不存在，则返回空</td></tr><tr><td>incr和decr相加相减</td><td>对已存在的 key(键) 的数字值进行自增或自减操作</td></tr><tr><td>stats（统计状态命令）</td><td>返回统计信息例如 PID(进程号)、版本号、连接数等</td></tr></tbody></table></li><li><p>缓存命中：命中数（get获取到数据）/获取次数（get的次数）</p></li><li><p>缓存穿透：</p><p>访问的数据，数据库不存在的数据，每次都不能够生成缓存，每次请求都直接访问数据库，穿透了缓存，缓存没有起到作用。数据库压力没有得到缓解。</p><p>解决方案，数据库查不到的，也做一个空缓存。</p></li><li><p>缓存雪崩</p><p> 缓存具有失效时间，如果缓存失效时间都是一样，本来应该请求缓存的，但是因为缓存失效了，全部请求到了数据库，数据库压力剧增，可能会造成数据库宕机，进而造成系统崩溃。</p><p> 解决方案，设置缓存的失效时间均匀分布。</p></li></ul><h3 id="失效机制"><a href="#失效机制" class="headerlink" title="失效机制"></a>失效机制</h3><ul><li><p>Lazy Expiration    </p><p>memcached 内部不会监视记录是否过期，而是在 get时查看记录的时间戳，检查记录是否过期。这种技术被称为 lazy（惰性）expiration。因此，memcached 不会在过期监视上耗费 CPU 时间。</p><p>比如php的里session机制 懒惰机制 php垃圾回收机制 gc回收  python 变量垃圾回收机制。</p></li><li><p>LRU</p><p>memcached 会优先使用已超时的记录的空间，但即使如此，也会发生追加新记录时空间不足的情况，此时就要使用名为 Least Recently Used（LRU）机制来分配空间。顾名思义，这是删除“最近最少使用”的记录的机制。因此，当 memcached 的内存空间不足时，就从最近未被使用的记录中搜索，并将其空间分配给新的记录。从缓存的实用角度来看，该模型十分理想。</p><p>不过，有些情况下 LRU 机制反倒会造成麻烦。memcached 启动时通过“­M”参数可以禁止 LRU。</p></li></ul><h3 id="session入memcached共享"><a href="#session入memcached共享" class="headerlink" title="session入memcached共享"></a>session入memcached共享</h3><p>分布式负载均衡架构中，web服务器间的session是不共享（默认session存储在本地的文件的），会造成session校验不一致。校验验证码不通过，登录之后session不一致，造成无法判断是否登录。</p><p>解决方案：</p><p>①session生成校验在同一台服务器   nginx调度算法  ip_hash</p><p>②session共享   多台web服务器可以调用到session</p><h3 id="缓存热点数据"><a href="#缓存热点数据" class="headerlink" title="缓存热点数据"></a>缓存热点数据</h3><p>把经常访问到的数据，发生变动较小，可以存储到内存缓存中，提供使用速度。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;缓存中间件之memcached&quot;&gt;&lt;a href=&quot;#缓存中间件之memcached&quot; class=&quot;headerlink&quot; title=&quot;缓存中间件之memcached&quot;&gt;&lt;/a&gt;缓存中间件之memcached&lt;/h1&gt;&lt;h2 id=&quot;网站优化&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="memcached" scheme="https://www.opszn.com/categories/memcached/"/>
    
    
      <category term="缓存中间件" scheme="https://www.opszn.com/tags/%E7%BC%93%E5%AD%98%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>MySQL读写分离</title>
    <link href="https://www.opszn.com/2018/02/25/MySQL%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
    <id>https://www.opszn.com/2018/02/25/MySQL读写分离/</id>
    <published>2018-02-25T02:36:54.000Z</published>
    <updated>2019-08-15T02:20:02.631Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL读写分离"><a href="#MySQL读写分离" class="headerlink" title="MySQL读写分离"></a>MySQL读写分离</h1><h2 id="读写分离目的"><a href="#读写分离目的" class="headerlink" title="读写分离目的"></a>读写分离目的</h2><p><strong>数据库负载均衡</strong>：</p><p>​        当数据库请求增多时，单例数据库不能够满足业务需求。需要进行数据库实例的扩容。多台数据库同时相应请求。也就是说需要对数据库的请求，进行负载均衡</p><p>​        但是由于数据库服务特殊原因，数据库扩容基本要求为：数据的一致性和完整性。所以要保证多台数据库实例的数据一致性和完整性，以MySQL为例来说，官方提供了主从复制机制。</p><p><strong>读写分离：</strong></p><p>​         数据库的负载均衡不同于其他服务的负载均衡，数据要求一致性。基于主从复制的基础上，常见的数据库负载均衡使用的是读写分离方式。写入主数据库，读取到从数据库。可以认为数据库读写分离，是一种特殊的负载均衡实现。</p><p><strong>实际业务中，读写分离存在的一个问题，不够实时性。</strong></p><p>对于要求实时性高的业务</p><p>①缓存  写主库  写缓存  读缓存</p><p>②可以读主</p><p>③添加完数据之后，有一个跳转等待的时间（5s），数据正在审核中</p><p><strong>①业务代码的读写分离</strong></p><p>需要在业务代码中，判断数据操作是读还是写，读连接从数据服务器操作，写连接主数据库服务器操作</p><p>以当前LNMP为例，需要通过PHP代码实现读写分离</p><p><strong>②中间件代理方式的读写分离</strong></p><p>在业务代码中，数据库的操作，不直接连接数据库，而是先请求到中间件服务器（代理）</p><p>由代理服务器，判断是读操作去从数据服务器，写操作去主数据服务器</p><table><thead><tr><th>MySQL Proxy</th><th>MySQL官方 测试版 不再维护</th></tr></thead><tbody><tr><td>Atlas</td><td>奇虎360 基于MySQL Proxy <a href="https://github.com/Qihoo360/Atlas" target="_blank" rel="noopener">https://github.com/Qihoo360/Atlas</a></td></tr><tr><td>DBProxy</td><td>美团点评</td></tr><tr><td>Amoeba</td><td>早期阿里巴巴</td></tr><tr><td>cobar</td><td>阿里巴巴</td></tr><tr><td>MyCat</td><td>基于阿里开源的Cobar</td></tr><tr><td>kingshared</td><td>go语言开发<a href="https://github.com/flike/kingshard" target="_blank" rel="noopener">https://github.com/flike/kingshard</a></td></tr><tr><td>proxysql</td><td><a href="http://www.proxysql.com/" target="_blank" rel="noopener">http://www.proxysql.com/</a></td></tr></tbody></table><p>数据库架构图如下：</p><p><img src="/2018/02/25/MySQL读写分离/1.png" alt></p><p>那么，应该如何进行选择？</p><p>①业务实现读写分离，操作方便，成本低，我们以LNMP架构为例，其支持读写分离。</p><p>②中间件代理服务器，除了能够实现读写分离，还可以作为数据库集群的管理平台。</p><h2 id="mycat实现读写分离"><a href="#mycat实现读写分离" class="headerlink" title="mycat实现读写分离"></a>mycat实现读写分离</h2><h3 id="mycat简介"><a href="#mycat简介" class="headerlink" title="mycat简介"></a>mycat简介</h3><p>Mycat 数据库中间件</p><p>国内最活跃的、性能最好的开源数据库中间件！</p><p>官方网址：<a href="http://www.mycat.io/" target="_blank" rel="noopener">http://www.mycat.io/</a></p><p><a href="https://github.com/MyCATApache/MyCAT-Server/" target="_blank" rel="noopener">https://github.com/MyCATApache/MyCAT-Server/</a></p><p>因为mycat是由java语言开发，必须使用java的运行环境才能进行启动和操作</p><h3 id="jdk与jre"><a href="#jdk与jre" class="headerlink" title="jdk与jre"></a>jdk与jre</h3><p>java 静态编译的编程语言 代码编译成机器码  执行机器码输出结果。</p><p>编译jdk  javac 编译java代码</p><p>运行 jre  编译好的机器码（可以执行文件）  java</p><p><strong>问：公司服务器部署的java环境是jdk还是jre？</strong></p><p>答：jre  java解析运行环境  一般情况编译过的可执行的java程序 ，jre就够用了。</p><p>jdk  javac 编译的环境  如果服务器上传是源代码文件 就可以编译，之后再执行。</p><p>实际业务环境中，如果存在需要编译的情况，就选择jdk。</p><p><strong>下载安装jdk</strong></p><p><a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar xvf jdk-<span class="number">8</span>u192-linux-x64.tar.gz</span><br><span class="line">mv jdk1.<span class="number">8.0</span>_192 /usr/local/java</span><br></pre></td></tr></table></figure><p><strong>添加环境变量</strong></p><p>为了我们操作的便捷性，我们将jdk添加到环境变量中</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#追加环境变量</span></span><br><span class="line"> echo <span class="string">"PATH=/usr/local/java/bin:<span class="variable">$PATH</span>"</span> &gt;&gt; /etc/profile</span><br><span class="line"> source /etc/profile</span><br><span class="line"><span class="comment">#检测java环境变量  如果看到版本信息即为成功 </span></span><br><span class="line"> java -version</span><br></pre></td></tr></table></figure><h3 id="配置读写分离"><a href="#配置读写分离" class="headerlink" title="配置读写分离"></a>配置读写分离</h3><p>配置文件解析：</p><table><thead><tr><th>文件名称</th><th>作用</th></tr></thead><tbody><tr><td>server.xml</td><td>配置mycat的对外的用户、密码、映射数据库名称等信息</td></tr><tr><td>schema.xml</td><td>配置后端真实数据库的用户、密码、真实数据库名称等信息</td></tr></tbody></table><p>Mycat是由java开发，java开发的软件大部分配置文件是xml格式。注意它的基本格式。</p><blockquote><p>xml格式注意点：</p><p>1、xml声明信息</p><p>2、具有一个根标签</p><p>3、双标签和单标签格式 </p><p>4、注意闭合标签 </p><p>5、注释格式为  <!--  这里是注释内容 --></p></blockquote><p><strong>server.xml解析</strong></p><p>默认其不用修改，但是当我们实际情况下，需要在里面配置对外的用户，密码，映射数据库信息</p><p><img src="/2018/02/25/MySQL读写分离/wps325.jpg" alt></p><p><strong>修改schema.xml</strong></p><p>schema标签里配置name的server.xml里的虚拟数据库名称，dataNode 填写后面使用的dataNode名称</p><p>dataNode标签和dataHost指定配置使用</p><p>dataHost标签里配置writeHost和readHost（密码，地址，用户名称）</p><p>我们可以看一下精简过后的配置文件</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span>?&gt;</span><br><span class="line">&lt;!DOCTYPE mycat:schema SYSTEM <span class="string">"schema.dtd"</span>&gt;</span><br><span class="line">&lt;mycat:schema xmlns:mycat=<span class="string">"http://io.mycat/"</span>&gt;</span><br><span class="line">    &lt;!-- <span class="number">1</span>、TESTDB和server.xml配置文件中的映射的数据库名称要一致   dataNone填写下面的dataNode名称 --&gt;</span><br><span class="line">&lt;schema name=<span class="string">"TESTDB"</span> checkSQLschema=<span class="string">"false"</span> sqlMaxLimit=<span class="string">"100"</span> dataNode=<span class="string">"dn3"</span>&gt;&lt;/schema&gt;</span><br><span class="line">&lt;!-- <span class="number">2</span>、dataNode name和上面的一致  dataHost填写下面的dataHost的name名称  database填写后端真实数据库名称--&gt;</span><br><span class="line">    &lt;dataNode name=<span class="string">"dn3"</span> dataHost=<span class="string">"localhost1"</span> database=<span class="string">"tp5shop"</span> /&gt;</span><br><span class="line">    &lt;!-- <span class="number">3</span>、可以配置负载均衡、读写分离算法   暂时可以不用动--&gt;</span><br><span class="line">&lt;dataHost name=<span class="string">"localhost1"</span> maxCon=<span class="string">"1000"</span> minCon=<span class="string">"10"</span> balance=<span class="string">"0"</span> writeType=<span class="string">"0"</span> dbType=<span class="string">"mysql"</span> dbDriver=<span class="string">"native"</span> switchType=<span class="string">"1"</span>  slaveThreshold=<span class="string">"100"</span>&gt;</span><br><span class="line">        &lt;!-- 对后端数据库服务器 发送的心跳检测 --&gt;</span><br><span class="line">&lt;heartbeat&gt;select user()&lt;/heartbeat&gt;</span><br><span class="line">&lt;!-- can have multi write hosts --&gt;</span><br><span class="line">        &lt;!-- <span class="number">4</span>、配置后端真实数据库的相关登录信息 --&gt;</span><br><span class="line">&lt;writeHost host=<span class="string">"hostM1"</span> url=<span class="string">"1.1.1.10:3306"</span> user=<span class="string">"tp5shop"</span> password=<span class="string">"<span class="variable">$Abc3721</span>"</span>&gt;</span><br><span class="line">&lt;!-- can have multi read hosts --&gt;</span><br><span class="line">&lt;readHost host=<span class="string">"hostS2"</span> url=<span class="string">"1.1.1.11:3306"</span> user=<span class="string">"tp5shop"</span> password=<span class="string">"<span class="variable">$Abc3721</span>"</span> /&gt;</span><br><span class="line">&lt;/writeHost&gt;</span><br><span class="line">&lt;!-- &lt;writeHost host=<span class="string">"hostS1"</span> url=<span class="string">"localhost:3316"</span> user=<span class="string">"root"</span> password=<span class="string">"123456"</span> /&gt;--&gt;</span><br><span class="line">&lt;!-- &lt;writeHost host=<span class="string">"hostM2"</span> url=<span class="string">"localhost:3316"</span> user=<span class="string">"root"</span> password=<span class="string">"123456"</span>/&gt; --&gt;</span><br><span class="line">&lt;/dataHost&gt;</span><br><span class="line">&lt;/mycat:schema&gt;</span><br></pre></td></tr></table></figure><p>修改完启动，查看是否有8066或9066端口启用（8066为客户端访问端口，9066为管理端访问端口）</p><p><strong>tip:</strong>mycat默认writeHost和readHost，如果writeHost不可用，则readHost也不可用。用两个writeHost，从的writeHost变成可写的了，要在slave服务器上设置readonly。</p><h3 id="balance属性和writeType属性"><a href="#balance属性和writeType属性" class="headerlink" title="balance属性和writeType属性"></a>balance属性和writeType属性</h3><p><strong>balance</strong></p><table><thead><tr><th>balance值</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>不开启读写分离，所有读操作均分发给writeHost</td></tr><tr><td>1</td><td>所有的readHost与备writeHost均参与读操作的负载均衡</td></tr><tr><td>2</td><td>读操作随机分发readHost与writeHost</td></tr><tr><td>3</td><td>读操作只分发给writeHost对应的readHost上，writeHost不分担读请求（1.4或更高版本有）</td></tr></tbody></table><p><strong>writeType</strong></p><table><thead><tr><th>writeType值</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>写操作发送给配置的第一个writeHost，挂后给第二个，第一个启动此时为“第二个”</td></tr><tr><td>1</td><td>写操作随机分发所有的writeHost，1.5后废弃，不推荐</td></tr></tbody></table><p><strong>switchType</strong></p><table><thead><tr><th>switchType值</th><th>说明</th></tr></thead><tbody><tr><td>-1</td><td>表示不切换</td></tr><tr><td>1</td><td>默认值，自动切换</td></tr><tr><td>2</td><td>基于mysql主从状态决定是否切换</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL读写分离&quot;&gt;&lt;a href=&quot;#MySQL读写分离&quot; class=&quot;headerlink&quot; title=&quot;MySQL读写分离&quot;&gt;&lt;/a&gt;MySQL读写分离&lt;/h1&gt;&lt;h2 id=&quot;读写分离目的&quot;&gt;&lt;a href=&quot;#读写分离目的&quot; class=&quot;head
      
    
    </summary>
    
      <category term="MySQL" scheme="https://www.opszn.com/categories/MySQL/"/>
    
    
      <category term="读写分离" scheme="https://www.opszn.com/tags/%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>MySQL主从复制</title>
    <link href="https://www.opszn.com/2018/02/20/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <id>https://www.opszn.com/2018/02/20/MySQL主从复制/</id>
    <published>2018-02-20T09:21:48.000Z</published>
    <updated>2019-08-14T08:04:06.065Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL主从复制"><a href="#MySQL主从复制" class="headerlink" title="MySQL主从复制"></a>MySQL主从复制</h1><h2 id="应用背景"><a href="#应用背景" class="headerlink" title="应用背景"></a>应用背景</h2><p>随着访问量不断提升, 单台mysql不断地逼近承载的负载极限。所以我们希望能用多台服务器来提供服务，这样不仅可以多台mysql数据库分担负载，而且也在一定程度上提供了冗余，可以在实现了自动备份的基础上进一步提供服务可用性。</p><p>这样多台mysql服务器架构数据需要保持一致,  所以我们可以选用mysql主从复制架构来实现。</p><h2 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h2><p>master将数据库的改变写入二进制日志，slave同步这些二进制日志，并根据这些二进制日志进行数据重演操作，实现数据同步, 这种同步默认为单向, 异步的.</p><p><img src="/2018/02/20/MySQL主从复制/1.png" alt></p><p><strong>详细描述：</strong></p><ol><li>slave端的IO线程发送请求给master端的binlog dump线程。</li><li>master端binlog dump线程获取二进制日志信息(文件名和位置信息)发送给slave端的IO线程。</li><li>salve端IO线程获取到的内容依次写到slave端relay log里，并把master端的bin-log文件名和位置记录到master.info里。</li><li>salve端的SQL线程，检测到relay  log中内容更新，就会解析relay log里更新的内容，并执行这些操作，从而达到和master数据一致。</li></ol><p><strong>常见复制模式：</strong></p><ol><li><p>一主一从（AB复制）：一般主写从读，可用于实现读写分离。</p><p><img src="/2018/02/20/MySQL主从复制/2.png" alt></p></li><li><p>一主多从（并联复制）：分担了slave的读压力，增加了master传输binlog的压力，使用读多写少的场景。</p><p><img src="/2018/02/20/MySQL主从复制/3.png" alt></p></li><li><p>级联复制：压力分担合适，但若某节点故障，后续节点将无法同步数据，并且此种模式延时很高。</p><p><img src="/2018/02/20/MySQL主从复制/4.png" alt></p></li><li><p>双主：两节点均可读写，业务中一般还是一读一写。当master故障，slave也可以写，并且通过binlog同步至master。</p><p><img src="/2018/02/20/MySQL主从复制/5.png" alt></p></li></ol><h2 id="搭建思路解析"><a href="#搭建思路解析" class="headerlink" title="搭建思路解析"></a>搭建思路解析</h2><ol><li>master和slave安装相同版本mysql</li><li>master端必须开启二进制日志；slave端必须开启relay log日志, slave可不开二进制日志</li><li>master端和slave端的server-id号必须不能一致。</li><li>slave端配置向master来同步数据。<ul><li>master端必须创建一个复制用户。</li><li>保证master和slave端初始数据一致。</li><li>配置主从复制（slave端）。</li></ul></li></ol><p>*<em>1.部分配置 *</em></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">master配置</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">...</span><br><span class="line">log-bin=binlog</span><br><span class="line">server-id=<span class="number">100</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">slave配置</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">...</span><br><span class="line">server-id=<span class="number">200</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>2.master创建授权用户</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grant replication slave on *.* to <span class="string">'slave'</span><span class="string">@'1.1.1.10' identified by 'password';</span></span><br><span class="line"><span class="string">flush privileges;</span></span><br></pre></td></tr></table></figure><p><strong>3.查看binlog位置</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">show master status;</span><br><span class="line">+---------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| File          | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span><br><span class="line">+---------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| binlog.<span class="number">000002</span> |      <span class="number">406</span> |              |                  |                   |</span><br><span class="line">+---------------+----------+--------------+------------------+-------------------+</span><br></pre></td></tr></table></figure><p><strong>4.slave上配置复制连接</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@vm2 ~]<span class="comment"># /mysql56/bin/mysql -p</span></span><br><span class="line">Enter password:</span><br><span class="line"></span><br><span class="line">mysql&gt; change master to</span><br><span class="line">    -&gt; master_host=<span class="string">'1.1.1.10'</span>,</span><br><span class="line">    -&gt; master_user=<span class="string">'slave'</span>,</span><br><span class="line">    -&gt; master_password=<span class="string">'password'</span>,</span><br><span class="line">    -&gt; master_port=<span class="number">3307</span>,</span><br><span class="line">    -&gt; master_log_file=<span class="string">'binlog.000002'</span>,</span><br><span class="line">    -&gt; master_log_pos=<span class="number">406</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>master_host</td><td>master的ip</td></tr><tr><td>master_user</td><td>复制的用户</td></tr><tr><td>master_password</td><td>复制用户密码</td></tr><tr><td>master_port</td><td>master的端口号</td></tr><tr><td>master_log_file</td><td>指定复制开始的日志文件</td></tr><tr><td>master_log_pos</td><td>指定复制开始的日志位置(position)</td></tr></tbody></table><p><strong>5.启动主从复制</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; start slave;</span><br><span class="line">mysql&gt; show slave status/G</span><br><span class="line">......</span><br><span class="line">            Slave_IO_Running: Yes 代表成功连接到master并且下载日志</span><br><span class="line">            Slave_SQL_Running: Yes 代表成功执行日志中的SQL语句</span><br><span class="line">                ......</span><br></pre></td></tr></table></figure><p><strong>小结：</strong></p><p>1.此主从复制结构为单向异步的，master可以做写操作，slave不可写。</p><p>2.master必须开启binlog。</p><p>3双节点server-id需要不一致。</p><h2 id="基于GTIDs的AB复制架构-M-S"><a href="#基于GTIDs的AB复制架构-M-S" class="headerlink" title="基于GTIDs的AB复制架构(M-S)"></a>基于GTIDs的AB复制架构(M-S)</h2><h3 id="GTIDS简介"><a href="#GTIDS简介" class="headerlink" title="GTIDS简介"></a><strong>GTIDS简介</strong></h3><p>什么是GTIDs以及有什么特点？</p><p>GTIDs（Global transaction identifiers）全局事务标识符，是mysql 5.6新加入的一项技术</p><ol><li><p>当使用GTIDs时，每一个事务都可以被识别并且跟踪</p></li><li><p>添加新的slave或者当发生故障需要将master身份或者角色迁移到slave上时，都无需考虑是哪一个二进制日志以及哪个position值，<strong>极大简化了相关操作</strong></p></li><li><p>GTIDs是完全基于事务的，因此<strong>不支持MYISAM存储引擎</strong></p></li><li><p>GTID由source_id和transaction_id组成： </p><p>1）source_id来自于server_uuid,可以在auto.cnf中看到</p><p>2）transation_id是一个序列数字，自动生成.</p></li></ol><p>通俗地说, <strong>==基于GTIDs的复制架构不用再烦恼指定哪个连接position了==</strong>。</p><h3 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a><strong>搭建过程</strong></h3><p><strong>1.配置文件修改</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">master部分配置文件修改</span><br><span class="line"></span><br><span class="line">gtid-mode=on                    这一行开始后<span class="number">3</span>句需要在master配置文件里增加</span><br><span class="line">log-slave-updates=<span class="number">1</span>             将relay-log里的记录同步到bin-log日志中 </span><br><span class="line">enforce-gtid-consistency        强制一致性</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">slave部分配置文件修改</span><br><span class="line"></span><br><span class="line">log-bin=slave-binlog这一行开始后<span class="number">4</span>句需要在slave配置文件里增加</span><br><span class="line">gtid-mode=on</span><br><span class="line">log-slave-updates=<span class="number">1</span></span><br><span class="line">enforce-gtid-consistency</span><br></pre></td></tr></table></figure><p><strong>说明:</strong><br>1, 开启GITDs需要在master和slave上都配置gtid-mode，log-bin，log-slave-updates，enforce-gtid-consistency（该参数在5.6.9之前是–disable-gtid-unsafe-statement）<br>3, 基于GTIDs复制<strong>从服务器必须开启二进制日志！</strong></p><p><strong>2.重新配置连接</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@vm2 ~]<span class="comment"># /mysql56/bin/mysql -p</span></span><br><span class="line">Enter password:</span><br><span class="line"></span><br><span class="line">mysql&gt; change master to</span><br><span class="line">    -&gt; master_host=<span class="string">'1.1.1.10'</span>,</span><br><span class="line">    -&gt; master_user=<span class="string">'slave'</span>,</span><br><span class="line">    -&gt; master_password=<span class="string">'password'</span>,</span><br><span class="line">    -&gt; master_port=<span class="number">3307</span>,</span><br><span class="line">    -&gt; master_auto_position=<span class="number">1</span>;不用指定从哪个二进制的哪个positon开始复制了</span><br></pre></td></tr></table></figure><h2 id="其他类型主从搭建思路"><a href="#其他类型主从搭建思路" class="headerlink" title="其他类型主从搭建思路"></a>其他类型主从搭建思路</h2><p>1.一主多从：几个从就做几次主从配置。</p><p>2.双主：互为主从分别做一次主从配置。</p><p>3.级联：中间的机器打开二进制日志和<code>log-slave-updates=1</code>参数然后master-slave1做一次AB复制, slave1-slave2再做一次AB复制。</p><h2 id="半同步复制"><a href="#半同步复制" class="headerlink" title="半同步复制"></a>半同步复制</h2><p>上面我们提到的复制架构默认来说都是单向的异步的复制，也就是说主将日志信息发送给从，动作就结束了，不会验证从库是否接收完毕，这样性能固然最佳，但是其风险也是很大的。</p><p>当主服务器或者从服务器发生故障时，极有可能从服务器没有接到主服务器发过来的binglog日志，这样就会导致主从数据不一致，甚至导致数据丢失。</p><p>为了解决该问题，mysql5.5引入了半同步复制模式。</p><p><img src="/2018/02/20/MySQL主从复制/6.png" alt></p><p>所谓的半同步复制就是master每commit一个事务(简单来说就是做一个改变数据的操作）,要确保slave接受完主服务器发送的binlog日志文件并写入到自己的中继日志relay log里，然后会给master信号，告诉对方已经接收完毕，这样master才能把事物成功commit。这样就保证了master-slave的数据绝对的一致（但是以牺牲master的性能为代价).如果slave挂了,master不可能永远等待slave的信号,默认等待10秒则转为异步。(等待时间也是可以调整的)。</p><h3 id="搭建过程-1"><a href="#搭建过程-1" class="headerlink" title="搭建过程"></a>搭建过程</h3><p><strong>1.前提</strong></p><p>需要我们已经搭建了上述的异步复制的类型中的一种。</p><p><strong>2.插件安装</strong></p><p>master：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">install plugin rpl_semi_sync_master soname <span class="string">'semisync_master.so'</span>;</span><br><span class="line"></span><br><span class="line">查看是否安装成功</span><br><span class="line">mysql&gt; show global variables like <span class="string">'rpl_semi_sync%'</span>;</span><br><span class="line">+------------------------------------+-------+</span><br><span class="line">| Variable_name                      | Value |</span><br><span class="line">+------------------------------------+-------+</span><br><span class="line">| rpl_semi_sync_master_enabled       | OFF   |是否启用master的半同步复制</span><br><span class="line">| rpl_semi_sync_master_timeout       | <span class="number">10000</span> |默认主等待从返回信息的超时间时间，<span class="number">10</span>秒。动态可调</span><br><span class="line">| rpl_semi_sync_master_trace_level   | <span class="number">32</span>    |用于开启半同步复制模式时的调试级别，默认是<span class="number">32</span> </span><br><span class="line">| rpl_semi_sync_master_wait_no_slave | ON    |是否允许每个事物的提交都要等待slave的信号</span><br><span class="line">+------------------------------------+-------+</span><br></pre></td></tr></table></figure><p>slave:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> install plugin rpl_semi_sync_slave soname <span class="string">'semisync_slave.so'</span>;</span><br><span class="line"> </span><br><span class="line"> mysql&gt; show global variables like <span class="string">'rpl_semi_sync%'</span>;</span><br><span class="line">+---------------------------------+-------+</span><br><span class="line">| Variable_name                   | Value |</span><br><span class="line">+---------------------------------+-------+</span><br><span class="line">| rpl_semi_sync_slave_enabled     | OFF   |   slave是否启用半同步复制</span><br><span class="line">| rpl_semi_sync_slave_trace_level | <span class="number">32</span>    |</span><br><span class="line">+---------------------------------+-------+</span><br></pre></td></tr></table></figure><p><strong>3.激活</strong></p><p>master：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> set global rpl_semi_sync_master_enabled =on;</span><br><span class="line"> show global variables like <span class="string">'rpl_semi_sync%'</span>;</span><br><span class="line"> </span><br><span class="line"> mysql&gt;  show global variables like <span class="string">'rpl_semi_sync%'</span>;</span><br><span class="line">+------------------------------------+-------+</span><br><span class="line">| Variable_name                      | Value |</span><br><span class="line">+------------------------------------+-------+</span><br><span class="line">| rpl_semi_sync_master_enabled       | ON    |  现在为ON了</span><br><span class="line">| rpl_semi_sync_master_timeout       | <span class="number">10000</span> |</span><br><span class="line">| rpl_semi_sync_master_trace_level   | <span class="number">32</span>    |</span><br><span class="line">| rpl_semi_sync_master_wait_no_slave | ON    |</span><br><span class="line">+------------------------------------+-------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">show global status like <span class="string">'rpl_semi_sync%'</span>;</span><br><span class="line">+--------------------------------------------+-------+</span><br><span class="line">| Variable_name                              | Value |</span><br><span class="line">+--------------------------------------------+-------+</span><br><span class="line">| Rpl_semi_sync_master_clients               | <span class="number">1</span>     |有一个从服务器启用半同步复制</span><br><span class="line">| Rpl_semi_sync_master_net_avg_wait_time     | <span class="number">0</span>     |master等slave的平均等待时间。单位毫秒</span><br><span class="line">| Rpl_semi_sync_master_net_wait_time         | <span class="number">0</span>     |master总的等待时间。单位毫秒</span><br><span class="line">| Rpl_semi_sync_master_net_waits             | <span class="number">0</span>     |master等待slave回复的总的等待次数</span><br><span class="line">| Rpl_semi_sync_master_no_times              | <span class="number">0</span>     |master关闭半同步复制的次数</span><br><span class="line">| Rpl_semi_sync_master_no_tx                 | <span class="number">0</span>     |表示从服务器确认的不成功提交的数量</span><br><span class="line">| Rpl_semi_sync_master_status                | ON    |标记master现在是否是半同步复制状态</span><br><span class="line">| Rpl_semi_sync_master_timefunc_failures     | <span class="number">0</span>     |master调用时间失败的次数</span><br><span class="line">| Rpl_semi_sync_master_tx_avg_wait_time      | <span class="number">0</span>     |master花在每个事务上的平均等待时间</span><br><span class="line">| Rpl_semi_sync_master_tx_wait_time          | <span class="number">0</span>     |master花在事物上总的等待时间</span><br><span class="line">| Rpl_semi_sync_master_tx_waits              | <span class="number">0</span>     |master事物等待次数</span><br><span class="line">| Rpl_semi_sync_master_wait_pos_backtraverse | <span class="number">0</span>     |后来的先到了，而先来的还没有到的次数</span><br><span class="line">| Rpl_semi_sync_master_wait_sessions         | <span class="number">0</span>     |多少个session因为slave回复而造成等待</span><br><span class="line">| Rpl_semi_sync_master_yes_tx                | <span class="number">0</span>     |表示从服务器确认的成功提交数量</span><br><span class="line">+--------------------------------------------+-------+</span><br></pre></td></tr></table></figure><p>slave:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set global rpl_semi_sync_slave_enabled=on;</span><br><span class="line">show global variables like <span class="string">'rpl_semi_sync%'</span>;</span><br><span class="line"> +----------------------------+-------+</span><br><span class="line">| Variable_name              | Value |</span><br><span class="line">+----------------------------+-------+</span><br><span class="line">| Rpl_semi_sync_slave_status | ON    |</span><br><span class="line">+----------------------------+-------+</span><br></pre></td></tr></table></figure><p><strong>4.重启slave的IO线程</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stop slave IO_THREAD;</span><br><span class="line">start slave IO_THREAD;</span><br></pre></td></tr></table></figure><p><strong>小结：</strong></p><p>当slave从库的IO_Thread 线程将binlog日志接受完毕后，要给master一个确认，如果超过10s未收到slave的接收确认信号，那么就会自动转换为传统的异步复制模式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL主从复制&quot;&gt;&lt;a href=&quot;#MySQL主从复制&quot; class=&quot;headerlink&quot; title=&quot;MySQL主从复制&quot;&gt;&lt;/a&gt;MySQL主从复制&lt;/h1&gt;&lt;h2 id=&quot;应用背景&quot;&gt;&lt;a href=&quot;#应用背景&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="MySQL" scheme="https://www.opszn.com/categories/MySQL/"/>
    
    
      <category term="主从复制" scheme="https://www.opszn.com/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    
  </entry>
  
</feed>
